<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.1" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="Ray 的藏书阁">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Ray 的藏书阁">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ray Chen">
<meta name="twitter:card" content="summary"><title>Ray 的藏书阁</title><link ref="canonical" href="http://example.com/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Ray 的藏书阁</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/12/10/golang-sync-map/">sync.Map 源码阅读</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-12-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-01-22</span></span></div></header><div class="post-body"><div class="post-excerpt"><!-- ---
layout: post
title: sync.Map源码圆度
author: Ray Chan(ray1888)
date: '2020-12-10 16:07:38 +0800'
category: Golang
summary: sync.Map implate 
thumbnail: go.png
--- -->



        <h1 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h1>
      <p>Sync.Map  是Golang 官方提供的线程安全的 map类库，因为Golang 本身自带的map并不是线程安全的，因为会有sync.Map这个类库的存在</p>

        <h1 id="实现"   >
          <a href="#实现" class="heading-link"><i class="fas fa-link"></i></a>实现</h1>
      
        <h2 id="基础元素"   >
          <a href="#基础元素" class="heading-link"><i class="fas fa-link"></i></a>基础元素</h2>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">type Map struct &#123;</span><br><span class="line">    mu Mutex</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; read contains the portion of the map&#39;s contents that are safe for</span><br><span class="line">    &#x2F;&#x2F; concurrent access (with or without mu held).</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; The read field itself is always safe to load, but must only be stored with</span><br><span class="line">    &#x2F;&#x2F; mu held.</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; Entries stored in read may be updated concurrently without mu, but updating</span><br><span class="line">    &#x2F;&#x2F; a previously-expunged entry requires that the entry be copied to the dirty</span><br><span class="line">    &#x2F;&#x2F; map and unexpunged with mu held.</span><br><span class="line">    read atomic.Value &#x2F;&#x2F; readOnly</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; dirty contains the portion of the map&#39;s contents that require mu to be</span><br><span class="line">    &#x2F;&#x2F; held. To ensure that the dirty map can be promoted to the read map quickly,</span><br><span class="line">    &#x2F;&#x2F; it also includes all of the non-expunged entries in the read map.</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; Expunged entries are not stored in the dirty map. An expunged entry in the</span><br><span class="line">    &#x2F;&#x2F; clean map must be unexpunged and added to the dirty map before a new value</span><br><span class="line">    &#x2F;&#x2F; can be stored to it.</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; If the dirty map is nil, the next write to the map will initialize it by</span><br><span class="line">    &#x2F;&#x2F; making a shallow copy of the clean map, omitting stale entries.</span><br><span class="line">    dirty map[interface&#123;&#125;]*entry</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; misses counts the number of loads since the read map was last updated that</span><br><span class="line">    &#x2F;&#x2F; needed to lock mu to determine whether the key was present.</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; Once enough misses have occurred to cover the cost of copying the dirty</span><br><span class="line">    &#x2F;&#x2F; map, the dirty map will be promoted to the read map (in the unamended</span><br><span class="line">    &#x2F;&#x2F; state) and the next store to the map will make a new dirty copy.</span><br><span class="line">    misses int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; readOnly is an immutable struct stored atomically in the Map.read field.</span><br><span class="line">type readOnly struct &#123;</span><br><span class="line">    m       map[interface&#123;&#125;]*entry</span><br><span class="line">    amended bool &#x2F;&#x2F; true if the dirty map contains some key not in m.</span><br><span class="line">&#125;</span><br><span class="line">type entry struct &#123;</span><br><span class="line">    &#x2F;&#x2F; p points to the interface&#123;&#125; value stored for the entry.</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; If p &#x3D;&#x3D; nil, the entry has been deleted and m.dirty &#x3D;&#x3D; nil.</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; If p &#x3D;&#x3D; expunged, the entry has been deleted, m.dirty !&#x3D; nil, and the entry</span><br><span class="line">    &#x2F;&#x2F; is missing from m.dirty.</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; Otherwise, the entry is valid and recorded in m.read.m[key] and, if m.dirty</span><br><span class="line">    &#x2F;&#x2F; !&#x3D; nil, in m.dirty[key].</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; An entry can be deleted by atomic replacement with nil: when m.dirty is</span><br><span class="line">    &#x2F;&#x2F; next created, it will atomically replace nil with expunged and leave</span><br><span class="line">    &#x2F;&#x2F; m.dirty[key] unset.</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; An entry&#39;s associated value can be updated by atomic replacement, provided</span><br><span class="line">    &#x2F;&#x2F; p !&#x3D; expunged. If p &#x3D;&#x3D; expunged, an entry&#39;s associated value can be updated</span><br><span class="line">    &#x2F;&#x2F; only after first setting m.dirty[key] &#x3D; e so that lookups using the dirty</span><br><span class="line">    &#x2F;&#x2F; map find the entry.</span><br><span class="line">    p unsafe.Pointer &#x2F;&#x2F; *interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>sync.Map 存储数据的分为两个部分：<br>1.read元素，使用的是atomic.Value 把map 当成interface进行存储；<br>2. dirty 一个golang中的一个Map，用于临时存储部分新的数据（具体场景会在后面进行描述）</p>

        <h2 id="写流程"   >
          <a href="#写流程" class="heading-link"><i class="fas fa-link"></i></a>写流程</h2>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.  判断Key是否再Read部分，如果在read部分，则直接采用cas来更换，更换成功则直接返回</span><br><span class="line">2.  否则就要加锁然后修改到dirty中，</span><br><span class="line">      有三种情况：</span><br><span class="line">      1. 在Read中，但是已经被修改，cas无法修改成功（会先把这个key对应的值与mark无效的指针做对比，如果是，则需要把这个更换了的key对应的放到dirty里面）</span><br><span class="line">      2. 在dirty 中，直接进行修改</span><br><span class="line">      3. 是一个新Key的情况下，如果dirty没有key不在read中，直接修改dirty,并且把需要读修正的Flag（read.amend &#x3D; true置入）</span><br><span class="line">3. 解锁</span><br></pre></td></tr></table></div></figure>
<p>因此 如果当key在Read中，是可以保证一个比较快的实现，因为用的是cas的比较方法，而不是直接加锁去防止竞争锁带来的性能损失。</p>

        <h2 id="读流程"   >
          <a href="#读流程" class="heading-link"><i class="fas fa-link"></i></a>读流程</h2>
      <ol>
<li> 读取Read中是否存在此Key，若存在则直接返回</li>
<li> 当发现key不存在于read，并且没有读修正的时候，直接返回</li>
<li> 发现需要读修正的情况下，会顺便把dirty中的数据置入到read中，并且返回值</li>
</ol>

        <h2 id="LoadORStore-读写一体流程"   >
          <a href="#LoadORStore-读写一体流程" class="heading-link"><i class="fas fa-link"></i></a>LoadORStore 读写一体流程</h2>
      
        <h1 id="用于阅读sync-Map的触发代码"   >
          <a href="#用于阅读sync-Map的触发代码" class="heading-link"><i class="fas fa-link"></i></a>用于阅读sync.Map的触发代码</h1>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    &#x2F;&#x2F; for testing sync.map work</span><br><span class="line"></span><br><span class="line">    var ma sync.Map</span><br><span class="line">    k, _ :&#x3D; ma.Load(&quot;a&quot;)</span><br><span class="line">    fmt.Println(k)</span><br><span class="line"></span><br><span class="line">    ma.Store(&quot;a&quot;, 1)</span><br><span class="line">    _, _ &#x3D; ma.Load(&quot;a&quot;)</span><br><span class="line">    ma.Store(&quot;b&quot;, 2)</span><br><span class="line">    ma.Store(&quot;a&quot;, 2)</span><br><span class="line">    ma.Store(&quot;a&quot;, 3)</span><br><span class="line">    p, _ :&#x3D; ma.Load(&quot;a&quot;)</span><br><span class="line">    fmt.Println(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>竞锁的情况</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></div></figure>


</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/01/22/gomodule/">gomodule</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-01-22</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-01-22</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="在线一对一迁移GoModule"   >
          <a href="#在线一对一迁移GoModule" class="heading-link"><i class="fas fa-link"></i></a>在线一对一迁移GoModule</h1>
      
        <h2 id="为什么需要迁移到GoModule"   >
          <a href="#为什么需要迁移到GoModule" class="heading-link"><i class="fas fa-link"></i></a>为什么需要迁移到GoModule</h2>
      <p>   主要是因为三个原因</p>
<ul>
<li> 从 Golang 1.13 以后， GoModule 已经从各种可用的方法由官方建议统一成 GoModule（并且事实上已经在比较成熟的 Golang 的开源项目中都已经开始进行采用）,也是为了便于升级 Golang Runtime 的版本来获取一些底层方面的性能提升</li>
<li> 可以使用 GoProxy 的中国实现解决实际生产上 Go 下载依赖包困难的问题(Golang 默认对于公开的开源库是会选择回源进行下载，但由于不可抗力，实际生产中下载依赖有可能触发一下404的域名，在不使用代理的情况下，无法下载依赖)</li>
<li> 目的是可以抛开 GOPATH 来更加自由的组织自己的项目</li>
</ul>

        <h2 id="GoModule-原理相关"   >
          <a href="#GoModule-原理相关" class="heading-link"><i class="fas fa-link"></i></a>GoModule 原理相关</h2>
      
        <h3 id="GoModule管理版本方式"   >
          <a href="#GoModule管理版本方式" class="heading-link"><i class="fas fa-link"></i></a>GoModule管理版本方式</h3>
      <p>   GoModule采用语义化版本管理方式来管理库名的版本。<br>   <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">此处在比较正式的软件工程的定义中，关于版本的定义如下：</span><br><span class="line">V $Major.$Minor.$Patch (eg: v2.10.1)</span><br><span class="line">其中定义：</span><br><span class="line">   - Major 为大版本，即默认期待为可能会有破坏性的变动，如Api的整体大变更</span><br><span class="line">   - Minor 为小版本，为引入新功能或者特性修改</span><br><span class="line">   - Patch 为补丁，一般来说是修复对应Minor版本中的部分问题</span><br></pre></td></tr></table></div></figure><br>   Golang 也引用了这个定义来进行 GoModule的构建。<br>   即如果包发生破坏性的变化，ModuleName 需要同时加一，以一个我们使用到的excel解析库为例子, 即 Major Version 升级也应该放入  ModuleName 中。</p>
   <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 原模块名</span><br><span class="line">github.com&#x2F;360EntSecGroup-Skylar&#x2F;excelize</span><br><span class="line">&#x2F;&#x2F; 发生变化后 </span><br><span class="line">github.com&#x2F;360EntSecGroup-Skylar&#x2F;excelize&#x2F;v2</span><br></pre></td></tr></table></div></figure>

<p>   但是上面例子为比较符合规范的类库，但实际上开发者不一定完全根据这个执行(大部分开发者会跟着规范去执行)，没有强制去进行规范化和提供规范化的工具。因此当使用或者升级第三方类库的情况下，最好还是自己去检查一下升级版本前后是否会有影响。</p>

        <h3 id="GONOPROXY-GONOSUMDB-GOPRIVATE-概念解析（私用仓库管理相关）"   >
          <a href="#GONOPROXY-GONOSUMDB-GOPRIVATE-概念解析（私用仓库管理相关）" class="heading-link"><i class="fas fa-link"></i></a>GONOPROXY/GONOSUMDB/GOPRIVATE 概念解析（私用仓库管理相关）</h3>
      <p>这三个环境变量都是用在当前项目依赖了私有模块，也就是依赖了由 GOPROXY 指定的 Go module proxy 或由 GOSUMDB 指定 Go checksum database 无法访问到的模块时的场景，他们具有如下特性：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">它们三个的值都是一个以英文逗号 “,” 分割的模块路径前缀，匹配规则同 path.Match。其中 GOPRIVATE 较为特殊，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是只是用 GOPRIVATE。</span><br><span class="line">在使用上来讲，比如 GOPRIVATE&#x3D;*.corp.example.com 表示所有模块路径以 corp.example.com 的下一级域名 (如 team1.corp.example.com) 为前缀的模块版本都将不经过 Go module proxy 和 Go checksum database，需要注意的是不包括 corp.example.com 本身。</span><br></pre></td></tr></table></div></figure>


        <h4 id="GOPROXY"   >
          <a href="#GOPROXY" class="heading-link"><i class="fas fa-link"></i></a>GOPROXY</h4>
      <p>这个环境变量主要是用于设置 Go 模块代理，主要如它的值是一个以英文逗号 “,” 分割的 Go module proxy 列表（稍后讲解）</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">作用：用于使 Go 在后续拉取模块版本时能够脱离传统的 VCS 方式从镜像站点快速拉取。它拥有一个默认值，但很可惜 proxy.golang.org 在中国无法访问，故而建议使用 goproxy.cn 作为替代。</span><br><span class="line">设置为 “off” ：禁止 Go 在后续操作中使用任 何 Go module proxy。</span><br><span class="line">刚刚在上面，我们可以发现值列表中有 “direct” ，它又有什么作用呢？</span><br><span class="line">其实值列表中的 “direct” 为特殊指示符，用于指示 Go 回源到模块版本的源地址去抓取 (比如 GitHub 等)，当值列表中上一个 Go module proxy 返回 404 或 410 错误时，Go 自动尝试列表中的下一个，遇见 “direct” 时回源，遇见 EOF 时终止并抛出类似 “invalid version: unknown revision...” 的错误。</span><br></pre></td></tr></table></div></figure>

<p>在安装go1.13之后，go会在系统默认使用goproxy.io来进行代理获取。但是由于不可抗力，我们在国内是无法使用这个goproxy的地址的，因此我们只能选用中国区的goproxy的实现。<br>目前主要有两个实现</p>
<ul>
<li> <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://goproxy.cn/" >七牛云 GOPROXY 地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li> <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://https//mirrors.aliyun.com/goproxy" >阿里云 GOPROXY 地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
<p>但是基于七牛云上面的 goproxy.cn 是目前国内较多GO开发者使用的 GOPROXY ，并且七牛在Go语言方面的布道和投入明显多于阿里的实现。目前我们使用七牛云的实现。（后续文章的配置均以goproxy.cn为GOPROXY变量的值）</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; go.mop go.mod 文件示例</span><br><span class="line">module gitlab.xinghuolive.com&#x2F;birds-backend&#x2F;phoenix</span><br><span class="line"> </span><br><span class="line">go 1.13</span><br><span class="line"> </span><br><span class="line">require (</span><br><span class="line">        github.com&#x2F;360EntSecGroup-Skylar&#x2F;excelize v1.4.1</span><br><span class="line">        gitlab.xinghuolive.com&#x2F;birds-backend&#x2F;migrations v0.0.0-20191202065617-b123ba4a7cdc</span><br><span class="line">        gopkg.in&#x2F;go-playground&#x2F;validator.v8 v8.18.2</span><br><span class="line">        gopkg.in&#x2F;mgo.v2 v2.0.0-20190816093944-a6b53ec6cb22</span><br><span class="line">        mellium.im&#x2F;sasl v0.2.1 &#x2F;&#x2F; indirect</span><br><span class="line">        ...</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>

<p>对于上面的模块每个字段的代表的是</p>
<ol>
<li>module 表示的是本项目的项目名称</li>
<li>go 1.13 代表使用的是go 1.13进行运行（这里只是用于展示，非强制性，这个是跟实际控制go mod 的go运行版本相关）</li>
<li>require 代表这个项目所依赖的第三方类库（包括公共库和私有库）require 的单个条目的组成为项目名称 version(-commit )</li>
</ol>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;示例：</span><br><span class="line">github.com&#x2F;robfig&#x2F;cron v1.2.0</span><br><span class="line">gitlab.xinghuolive.com&#x2F;birds-backend&#x2F;swan v0.0.0-20191112105628-9b584ccec9ef</span><br></pre></td></tr></table></div></figure>
<p>为什么会有上面的两种样式，原因是因为依赖的库的方式不同。<br />使用Go module 后依然可以用go get 来新加库（会自动把新依赖添加到go.mod文件中）。<br />但是可以支持以下方法来更新</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go get $project@latest 根据tag来进行拉取</span><br><span class="line">go get $project@master 根据branch来进行拉取</span><br><span class="line">go get $project@V1.0   根据版本号来获取</span><br><span class="line">go get $project@d4a36278507 根据commit号来获取</span><br></pre></td></tr></table></div></figure>
<p>因此会有着两种形式同时存在。</p>
<ul>
<li>如何管理私有库<br> 即使上面配置好了GOPROXY,但是实际上私有库也是不能直接获取到的，所以我们需要配置GOPRIVATE变量来告诉go module去构建的时候，这个直接走本地的gitlab去git clone，而且不是去外边去go get 外面的库。<br> 主要原因：<ul>
<li> GOPROXY 是无权访问到任何人的私有模块的，所以你放心，安全性没问题。</li>
<li> GOPROXY 除了设置模块代理的地址以外，还需要增加 “direct” 特殊标识才可以成功拉取私有库。</li>
</ul>
</li>
<li>同一类库的不同版本的处理<br>在GoModule中的预设，假设两个包的大版本如 v1,v2 。它理解为这里是发生了BreakingChange，它会默认把这种情况的两个版本当时两个包来引入。但是对于同一个版本上面的如v1.2和v1.3，它默认是没有破坏性的改动的，因此它会默认筛选更新的版本来进行使用。（可以通过Replace来指定本项目用到的这个包的版本）</li>
</ul>

        <h3 id="Replace的功能介绍"   >
          <a href="#Replace的功能介绍" class="heading-link"><i class="fas fa-link"></i></a>Replace的功能介绍</h3>
      <p>Replace 是 GoModule 中 允许用户进行依赖模块替换的功能<br>有大概如下三种用法：</p>
<ul>
<li>把已经消失的类库或者 Fork 出来的类库，使用这个来替换掉原来计算的代码</li>
<li>把不同层级引用的依赖进行归一化直接重定向到统一个目录下的一个库版本</li>
<li>把频繁改动的依赖库隔离其他人影响</li>
</ul>

        <h3 id="GoModule的依赖保留方式"   >
          <a href="#GoModule的依赖保留方式" class="heading-link"><i class="fas fa-link"></i></a>GoModule的依赖保留方式</h3>
      <ol>
<li>在目前使用了 GoModule 后，实际上所有的项目依赖都会保存到GOPATH[0]/pkg目录下【go1.13是这样的保留方式，1.14会放到 $GOMODCACHE 的变量路径中】，它会保留多个版本。<br>以penguin代码为例子，它会保留多个commit在本地来继续全局的统一保存。<img src="/2020/01/22/gomodule/dependies.png" class="" title="依赖位置图">


</li>
</ol>

        <h2 id="迁移过程"   >
          <a href="#迁移过程" class="heading-link"><i class="fas fa-link"></i></a>迁移过程</h2>
      
        <h3 id="1-梳理私有项目间的依赖"   >
          <a href="#1-梳理私有项目间的依赖" class="heading-link"><i class="fas fa-link"></i></a>1.梳理私有项目间的依赖</h3>
         

<p>   梳理私有项目间的依赖，以最底的依赖来开始迁移至 GoModule，然后逐层上升来构建GoModule。</p>
<p>   我们的处理逻辑是从Turkey和Swan开始入手改造项目变成使用 GoModule进行管理，再到Penguin，如此类推，知道所有应用层代码都变成了使用 GoModule进行管理。</p>

        <h3 id="2-解决依赖的问题"   >
          <a href="#2-解决依赖的问题" class="heading-link"><i class="fas fa-link"></i></a>2.解决依赖的问题</h3>
      <p>因此可能出现下面两种问题：</p>
<ol>
<li>依赖消失的情况[由于 Golang 在 GoModule之前是没有一套官方定义的统一方法去管理第三方的依赖，只会把代码托管在第三方的平台上(eg:github)，并且在历史上没有一个类似于其他语言社区有一个中心化的库管理的工具（如Python中的Pypi, Java中的Maven]</li>
</ol>
<ul>
<li>解决方案<br>对上面的这种情况，像项目中之前依赖的<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">github.com&#x2F;xiao100&#x2F;redis-pattern</span><br><span class="line">github.com&#x2F;xiao100&#x2F;compoent</span><br></pre></td></tr></table></div></figure>
两个类库的情况下，因为类库不算复杂并且比较小，我们目前的做法是直接把Vendor中的旧代码挪出来进入项目中自己进行管理.</li>
</ul>
<ol start="2">
<li>本项目的依赖和依赖项目的引用了同一个包的不同版本的问题</li>
</ol>
<ul>
<li>解决方案<br>本项目的依赖版本和依赖的依赖的项目版本不一致的情况<br>在上图提及 Magpie 的项目中用到 xiao100/cast 版本与 penguin 中用到的版本不一样，但是因为只是Cast的new方法是比较小的差异，新版本多返回了一个 error类 型，所以只要手动处理。（其实也可以理解为倒逼一些引用了的包比较旧的版本升级，只要测试充分，其实对系统的伤害不大，而且依赖库解决了一些潜在的 Bug)</li>
</ul>

        <h3 id="3-获取私有依赖的新版本的问题"   >
          <a href="#3-获取私有依赖的新版本的问题" class="heading-link"><i class="fas fa-link"></i></a>3.获取私有依赖的新版本的问题</h3>
      <ol>
<li>配置好相关的环境变量后, 在所在目录上面直接执行</li>
</ol>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get gitlab.xinghuovip.com&#x2F;birds-backend&#x2F;$project@($branch&#x2F;$gitTag&#x2F;$commitNumber)</span><br></pre></td></tr></table></div></figure>
<p>执行成功后，go.mod 文件会自动修改相关的依赖。</p>

        <h3 id="4-Replace-在开发中的使用"   >
          <a href="#4-Replace-在开发中的使用" class="heading-link"><i class="fas fa-link"></i></a>4. Replace 在开发中的使用</h3>
      <p>因为我们在项目中采用的是 GitFlow 的功能分支开发模式进行代码管理，因此每个人切换或者合并分支的频率是比较高的，因此，如果每次都要手动去 Go get 下层依赖的改动其实会特别繁琐，因此我们在开发中，如果会修改到下层依赖的代码时候，如 turkey 的代码，我们默认会把 go.mod 中 turkey 的引用修改成相对位置的引用,这样就能减少开发切换的成本，降低使用心智负担。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; go.mod</span><br><span class="line">module gitlab.xinghuolive.com&#x2F;birds-backend&#x2F;phoenix</span><br><span class="line"> </span><br><span class="line">go 1.13</span><br><span class="line"> </span><br><span class="line">require (</span><br><span class="line">    github.com&#x2F;360EntSecGroup-Skylar&#x2F;excelize&#x2F;v2 v2.1.0</span><br><span class="line">    github.com&#x2F;Shopify&#x2F;sarama v1.27.2</span><br><span class="line">    github.com&#x2F;aliyun&#x2F;aliyun-oss-go-sdk v2.1.4+incompatible</span><br><span class="line">    github.com&#x2F;bradfitz&#x2F;gomemcache v0.0.0-20190913173617-a41fca850d0b &#x2F;&#x2F; indirect</span><br><span class="line">    github.com&#x2F;bxcodec&#x2F;faker v2.0.1+incompatible</span><br><span class="line">    github.com&#x2F;bxcodec&#x2F;faker&#x2F;v3 v3.5.0</span><br><span class="line">    github.com&#x2F;cep21&#x2F;circuit v3.0.0+incompatible</span><br><span class="line">    github.com&#x2F;dgrijalva&#x2F;jwt-go v3.2.0+</span><br><span class="line">   ...</span><br><span class="line">)</span><br><span class="line">replace gitlab.xinghuolive.com&#x2F;birds-backend&#x2F;turkey &#x3D;&gt; ..&#x2F;turkey</span><br></pre></td></tr></table></div></figure>


        <h3 id="5-Jenkins构建脚本的修改"   >
          <a href="#5-Jenkins构建脚本的修改" class="heading-link"><i class="fas fa-link"></i></a>5. Jenkins构建脚本的修改</h3>
      <ol>
<li>修改了 build 函数里面的拉取的函数直接通过Go Get 去进行获取对应库的分支，以前采用的方式是使用 git clone 下来对应版本的私有代码到GOPATH来进行构建。</li>
<li>为了方便开发时功能分支的切换，而且降低开发人员对GoMod 文件管理的心智负担，我们在构建的时候会把 go mod 中的 replace 相关的内容在构建中通过shell命令给替换掉，保证了上线代码的版本必定是指定构建依赖的分支</li>
</ol>

        <h2 id="迁移GoModule后遇到的坑"   >
          <a href="#迁移GoModule后遇到的坑" class="heading-link"><i class="fas fa-link"></i></a>迁移GoModule后遇到的坑</h2>
      <ul>
<li>Jenkins构建上面的问题<br> 遇到一个比较大的坑是，实现的第一版的时候，想把pull本项目的代码与Go get 依赖放到同一个 Stage 中，build单独放到另外一个 Stage 中。但是发现在 Jenkin s中如果把 go get 放到 build 之外的 Stage 中，实际上并没有go get 依赖库新版本成功。因此最终是把go get 自己私有依赖和 build 放到了同一个 stage 就可以解决问题</li>
<li>依赖库版本管理的问题<br> 有一次在开发版本国中发生比较大的代码合入之后，直接使用 Go Mod tidy 整理依赖后，go.mod 文件重新计算依赖后，直接把我们的excel解析库的版本进行了升级，然后api发生了变动，经检查后，我们直接通过下面的go get 的命令来直接锁死了该库的版本 <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get  github.com&#x2F;360EntSecGroup-Skylar&#x2F;excelize&#x2F;v2@&lt;&#x3D;v2.1.0</span><br></pre></td></tr></table></div></figure>

</li>
</ul>

        <h2 id="本地切换-GoModule-使用方法"   >
          <a href="#本地切换-GoModule-使用方法" class="heading-link"><i class="fas fa-link"></i></a>本地切换 GoModule 使用方法</h2>
      
        <h3 id="Windows桌面开发环境"   >
          <a href="#Windows桌面开发环境" class="heading-link"><i class="fas fa-link"></i></a>Windows桌面开发环境</h3>
      <ol>
<li><p>安装Go1.13<br /></p>
<ol>
<li>在Goland中点击 File-&gt; Setting -&gt; GO -&gt; GOROOT<!-- ![image.png](https://cdn.nlark.com/yuque/0/2019/png/554199/1575364784373-2d4a8391-e531-4702-af07-8fc4dfc58daf.png#align=left&display=inline&height=438&margin=%5Bobject%20Object%5D&name=image.png&originHeight=876&originWidth=1286&size=68526&status=done&style=none&width=643) -->
<img src="/2020/01/22/gomodule/golang-setting-00000.png" class="" title="图1"></li>
<li>点击加号 -&gt; Download<!-- ![image.png](https://cdn.nlark.com/yuque/0/2019/png/554199/1575364793577-2d942479-b6ff-4108-b388-91ed23aebfc2.png#align=left&display=inline&height=368&margin=%5Bobject%20Object%5D&name=image.png&originHeight=735&originWidth=1295&size=53950&status=done&style=none&width=647.5) -->
<img src="/2020/01/22/gomodule/golang-setting-0000.png" class="" title="图2"></li>
<li>点击对应版本和选择安装这个Go版本的路径即可<!-- ![image.png](https://cdn.nlark.com/yuque/0/2019/png/554199/1575364801584-5e91b22b-a586-4f37-9ed1-c57db92d83bc.png#align=left&display=inline&height=242&margin=%5Bobject%20Object%5D&name=image.png&originHeight=484&originWidth=844&size=29828&status=done&style=none&width=422) -->
</li>
<li>然后使用go1.13.4 的sdk 即可<!-- ![image.png](https://cdn.nlark.com/yuque/0/2019/png/554199/1575364812491-04b111dd-c6b5-41fe-9919-ba0458b2ad17.png#align=left&display=inline&height=334&margin=%5Bobject%20Object%5D&name=image.png&originHeight=668&originWidth=1200&size=52419&status=done&style=none&width=600) -->

</li>
</ol>
</li>
<li><p>配置Go相关的变量<br /></p>
<ol>
<li> 把项目路径从GOPATH中删除（与添加GOPATH是相反的操作，此处不再展示）</li>
<li>执行下面的命令组,配置 GOPROXY 和 GOPRIVATE 环境变量（我的操作是在git shell 中，理论上在 cmd 也可以执行相同的命令）   <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn,direct</span><br><span class="line">go env -w GOPRIVATE&#x3D;gitlab.xinghuolive.com</span><br><span class="line"> </span><br></pre></td></tr></table></div></figure>
</li>
</ol>
</li>
<li><p>配置git相关的配置</p>
<ol>
<li><p>配置默认使用ssl 代替https仓库。在git shell中执行下面命令</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.gitconfig</span><br><span class="line">输入下面的内容</span><br><span class="line">[url &quot;ssh:&#x2F;&#x2F;git@gitlab.xinghuolive.com&#x2F;&quot;]</span><br><span class="line">   insteadOf &#x3D; https:&#x2F;&#x2F;gitlab.xinghuolive.com&#x2F;</span><br><span class="line">[url &quot;ssh:&#x2F;&#x2F;git@github.com&#x2F;&quot;]</span><br><span class="line">   insteadOf &#x3D; https:&#x2F;&#x2F;github.com&#x2F;</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>配置github的用户（方便拉取github源的情况免输入用户密码，如果本机有在github做公钥的话可以忽略这个）</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在bash中执行</span><br><span class="line">vim ~&#x2F;.netrc</span><br><span class="line">输入下面内容</span><br><span class="line">machine github.com login username $github_username password $github_password</span><br></pre></td></tr></table></div></figure>

<p>此处 $github_password 可以直接输入github账号的密码或者使用github生成的token</p>
</li>
</ol>
</li>
<li><p>在  IDE 项目中打开 GoModule 选项</p>
<ol>
<li>在 Goland 中点击 File-&gt; Setting -&gt; GO -&gt; Go Module<pre><code>![image.png](https://cdn.nlark.com/yuque/0/2019/png/554199/1575364828721-a5e60d60-bf10-4d8d-9aa3-965a1c8b4f77.png#align=left&amp;display=inline&amp;height=458&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=916&amp;originWidth=1348&amp;size=89362&amp;status=done&amp;style=none&amp;width=674)</code></pre>
</li>
</ol>
<p>Enable 勾选 -&gt; Proxy选项选择direct -&gt;  VendoringMode 选择关闭即可</p>
</li>
<li><p>然后进行愉快的Build即可，跟以前项目的使用没有任何差异。</p>
</li>
</ol>

        <h3 id="Linux环境配置"   >
          <a href="#Linux环境配置" class="heading-link"><i class="fas fa-link"></i></a>Linux环境配置</h3>
      <ol>
<li>如果是使用Goland IDE 按上面的操作即可，上面Windows的操作在git shell中执行的，可以直接使用shell执行即可</li>
</ol>

        <h2 id="FAQ"   >
          <a href="#FAQ" class="heading-link"><i class="fas fa-link"></i></a>FAQ</h2>
      
        <h3 id="开发中依赖变动导致build-失败情况"   >
          <a href="#开发中依赖变动导致build-失败情况" class="heading-link"><i class="fas fa-link"></i></a>开发中依赖变动导致build 失败情况</h3>
      <ol>
<li>直接更新 go.mod  依赖版本<br>在目前开发中如果依赖被改动导致build失败的情况下（如phoenix中的引用swan，swan被改动的情况下）目前的的处理方法是切到swan，然后拉取代码。<br>但是切到GoModule后，对于上面的情况我们可以直接在phoenix项目中，使用<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get gitlab.xinghuolive.com&#x2F;birds-backend&#x2F;swan@develop</span><br></pre></td></tr></table></div></figure>

</li>
</ol>
<p>即可以解决上面的依赖问题。不用切换到swan去进行代码拉取。  </p>
<ol start="2">
<li>使用 Replace 来进行<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -replace github.com&#x2F;pselle&#x2F;bar&#x3D;&#x2F;Users&#x2F;pselle&#x2F;Projects&#x2F;bar</span><br></pre></td></tr></table></div></figure>


</li>
</ol>

        <h2 id="Reference"   >
          <a href="#Reference" class="heading-link"><i class="fas fa-link"></i></a>Reference</h2>
      <ol>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/Modules" >GOMODULE-Wiki</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://golang.org/doc/faq#git_https" >GIT-HTTPS</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://go.googlesource.com/proposal/+/master/design/24301-versioned-go.md" >GoModule提案</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwNzEzNDMyNg==&mid=2247483722&idx=1&sn=4646d810dc43889ad72366b431a49609&chksm=9b038c53ac74054545baa60b5f1699dcfaebbada7846a92c8d6ebbc8086abfbd52ced2bd3823&mpshare=1&scene=1&srcid=&sharer_sharetime=1574906293192&sharer_shareid=9fbe1d93883d7c2a4204dcd9c62de80c&key=ee95545b6f7acc6e511bb0e9cb24d1742dc89a893cb5347267b56017b59057adc17c7a8177e405b3cc7e486cf1305c84565a9a4713040e05befb2c41c79d6ce2ca5dc08639bb1dd11a9204e47082d47c&ascene=1&uin=MjIyMDMyNTU4MA==&devicetype=Windows+10&version=62070152&lang=zh_CN&pass_ticket=ha1kk5e3DGz7oclEnTJnFqdqZBTlQCiYC73jFMAQnHWsgxruuE5pBu2d9rQ6iF/Q" >GoModule小结</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://goproxy.cn/" >七牛云GOPROXY的实现</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://https//mirrors.aliyun.com/goproxy" >阿里云GOPROXY的实现</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/10/06/prometheus-scrape/">Prometheus(1)- 数据抓取源码阅读</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-10-06</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-01-22</span></span></div></header><div class="post-body"><div class="post-excerpt"><!-- ---
layout: post
title: Prometheus数据抓取源码阅读
author: Ray Chan(ray1888)
date: '2019-10-06 15:31:38 +0800'
category: Prometheus
summary: Prometheus Scrape Module
thumbnail: Prometheus.png
--- -->



        <h1 id="目录"   >
          <a href="#目录" class="heading-link"><i class="fas fa-link"></i></a>目录</h1>
      <ol>
<li>使用的目的</li>
<li>代码实现</li>
</ol>

        <h1 id="代码版本"   >
          <a href="#代码版本" class="heading-link"><i class="fas fa-link"></i></a>代码版本</h1>
      <p>基于 prometheus项目的master branch的5a554df0855bf707a8c333c0dd830067d03422cf commit</p>

        <h1 id="使用目的"   >
          <a href="#使用目的" class="heading-link"><i class="fas fa-link"></i></a>使用目的</h1>
      <p>Prometheus 是一个基于Pull模型所进行数据采集的系统，因此，需要在主体项目中有一个抓取数据的模块，而Scrape就是这样的模块。因此这个也是Prometheus的一个主要部分。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">入口代码部分</span><br><span class="line">main.go</span><br><span class="line">&#x2F;&#x2F; line 356</span><br><span class="line">scrapeManager &#x3D; scrape.NewManager(log.With(logger, &quot;component&quot;, &quot;scrape manager&quot;), fanoutStorage)</span><br><span class="line">&#x2F;&#x2F; line 427</span><br><span class="line">scrapeManager.ApplyConfig</span><br><span class="line">&#x2F;&#x2F; line 555</span><br><span class="line">err :&#x3D; scrapeManager.Run(discoveryManagerScrape.SyncCh())</span><br></pre></td></tr></table></div></figure>

        <h1 id="代码实现"   >
          <a href="#代码实现" class="heading-link"><i class="fas fa-link"></i></a>代码实现</h1>
      
        <h2 id="整体的流程图"   >
          <a href="#整体的流程图" class="heading-link"><i class="fas fa-link"></i></a>整体的流程图</h2>
      <!-- ![ServiceDiscoveryModule](/assets/img/posts/prometheus/ScrapeModule.png) -->
<img src="/2019/10/06/prometheus-scrape/ScrapeModule.png" class="" title="ServiceDiscoveryModule">


        <h2 id="目录结构"   >
          <a href="#目录结构" class="heading-link"><i class="fas fa-link"></i></a>目录结构</h2>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 ray 197121  2239 9月  30 16:09 helpers_test.go</span><br><span class="line">-rw-r--r-- 1 ray 197121  7543 9月  30 16:09 manager.go   &#x2F;&#x2F;主要的控制的模块Manager</span><br><span class="line">-rw-r--r-- 1 ray 197121 10727 9月  30 16:09 manager_test.go</span><br><span class="line">-rw-r--r-- 1 ray 197121 35749 9月  30 16:09 scrape.go    &#x2F;&#x2F; 主要进行采集的模块</span><br><span class="line">-rw-r--r-- 1 ray 197121 40682 9月  30 16:09 scrape_test.go</span><br><span class="line">-rw-r--r-- 1 ray 197121 11743 9月  30 16:09 target.go    &#x2F;&#x2F;  抓取的公用部分的逻辑</span><br><span class="line">-rw-r--r-- 1 ray 197121  9542 9月  30 16:09 target_test.go</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h2 id="重要数据结构描述"   >
          <a href="#重要数据结构描述" class="heading-link"><i class="fas fa-link"></i></a>重要数据结构描述</h2>
      <p>ScrapeManager 是管理所有抓取的一个抽象</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Manager struct &#123;</span><br><span class="line">	logger    log.Logger</span><br><span class="line">	append    Appendable</span><br><span class="line">	graceShut chan struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">	jitterSeed    uint64     &#x2F;&#x2F; Global jitterSeed seed is used to spread scrape workload across HA setup.</span><br><span class="line">	mtxScrape     sync.Mutex &#x2F;&#x2F; Guards the fields below.</span><br><span class="line">	scrapeConfigs map[string]*config.ScrapeConfig</span><br><span class="line">	scrapePools   map[string]*scrapePool</span><br><span class="line">	targetSets    map[string][]*targetgroup.Group</span><br><span class="line"></span><br><span class="line">	triggerReload chan struct&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>ScrapePools 是单个的Job的抓取目标的工作单位</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">appendable Appendable</span><br><span class="line">	logger     log.Logger</span><br><span class="line"></span><br><span class="line">	mtx    sync.RWMutex</span><br><span class="line">	config *config.ScrapeConfig</span><br><span class="line">	client *http.Client</span><br><span class="line">	&#x2F;&#x2F; Targets and loops must always be synchronized to have the same</span><br><span class="line">	&#x2F;&#x2F; set of hashes.</span><br><span class="line">	activeTargets  map[uint64]*Target</span><br><span class="line">	droppedTargets []*Target</span><br><span class="line">	loops          map[uint64]loop</span><br><span class="line">	cancel         context.CancelFunc</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Constructor for new scrape loops. This is settable for testing convenience.</span><br><span class="line">	newLoop func(scrapeLoopOptions) loop</span><br></pre></td></tr></table></div></figure>
<p>loop是单个Target的执行单位，是一个接口。在这里主要使用的是ScrapeLoop的实例</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type loop interface &#123;</span><br><span class="line">	run(interval, timeout time.Duration, errc chan&lt;- error)</span><br><span class="line">	stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type scrapeLoop struct &#123;</span><br><span class="line">	scraper         scraper</span><br><span class="line">	l               log.Logger</span><br><span class="line">	cache           *scrapeCache</span><br><span class="line">	lastScrapeSize  int</span><br><span class="line">	buffers         *pool.Pool</span><br><span class="line">	jitterSeed      uint64</span><br><span class="line">	honorTimestamps bool</span><br><span class="line"></span><br><span class="line">	appender            func() storage.Appender</span><br><span class="line">	sampleMutator       labelsMutator</span><br><span class="line">	reportSampleMutator labelsMutator</span><br><span class="line"></span><br><span class="line">	parentCtx context.Context</span><br><span class="line">	ctx       context.Context</span><br><span class="line">	cancel    func()</span><br><span class="line">	stopped   chan struct&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>scraper接口时具体的执行单位，scrapeLoop也是调用scraper的方法来进行数据的抓取, Prometheus默认使用targetScraper去抓取数据</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">type scraper interface &#123;</span><br><span class="line">	scrape(ctx context.Context, w io.Writer) (string, error) &#x2F;&#x2F; 抓取数据的方法</span><br><span class="line">	report(start time.Time, dur time.Duration, err error)    &#x2F;&#x2F; 上报数据的方法</span><br><span class="line">	offset(interval time.Duration, jitterSeed uint64) time.Duration &#x2F;&#x2F; 记录数据偏移的方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type targetScraper struct &#123;</span><br><span class="line">	*Target  &#x2F;&#x2F;包含了report和offset方法</span><br><span class="line"></span><br><span class="line">	client  *http.Client &#x2F;&#x2F;因为Prometheus的exporter是以http接口进行数据的暴露的，所以会有httpclient的结构包含在里面</span><br><span class="line">	req     *http.Request</span><br><span class="line">	timeout time.Duration</span><br><span class="line"></span><br><span class="line">	gzipr *gzip.Reader</span><br><span class="line">	buf   *bufio.Reader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h2 id="主协程逻辑"   >
          <a href="#主协程逻辑" class="heading-link"><i class="fas fa-link"></i></a>主协程逻辑</h2>
      <p>跟着调用的部分，我们先从初始化后的manager的ApplyConfig方法开始看起。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">func (m *Manager) ApplyConfig(cfg *config.Config) error &#123;</span><br><span class="line">	m.mtxScrape.Lock()</span><br><span class="line">	defer m.mtxScrape.Unlock()</span><br><span class="line"></span><br><span class="line">	c :&#x3D; make(map[string]*config.ScrapeConfig)</span><br><span class="line">    </span><br><span class="line">	for _, scfg :&#x3D; range cfg.ScrapeConfigs &#123;</span><br><span class="line">		c[scfg.JobName] &#x3D; scfg</span><br><span class="line">	&#125;</span><br><span class="line">	m.scrapeConfigs &#x3D; c</span><br><span class="line">    &#x2F;&#x2F; 使用全局配置来生成一个集群内不重复的seed</span><br><span class="line">	if err :&#x3D; m.setJitterSeed(cfg.GlobalConfig.ExternalLabels); err !&#x3D; nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Cleanup and reload pool if the configuration has changed.</span><br><span class="line">	var failed bool</span><br><span class="line">    &#x2F;&#x2F; 根据解析出来的配置生成对应的ScrapePool， 如果有并且数据没有改变的话，那就不进行操作，否则</span><br><span class="line">	for name, sp :&#x3D; range m.scrapePools &#123;</span><br><span class="line">		if cfg, ok :&#x3D; m.scrapeConfigs[name]; !ok &#123;</span><br><span class="line">			sp.stop()</span><br><span class="line">			delete(m.scrapePools, name)</span><br><span class="line">		&#125; else if !reflect.DeepEqual(sp.config, cfg) &#123;</span><br><span class="line">			err :&#x3D; sp.reload(cfg)</span><br><span class="line">			if err !&#x3D; nil &#123;</span><br><span class="line">				level.Error(m.logger).Log(&quot;msg&quot;, &quot;error reloading scrape pool&quot;, &quot;err&quot;, err, &quot;scrape_pool&quot;, name)</span><br><span class="line">				failed &#x3D; true</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if failed &#123;</span><br><span class="line">		return errors.New(&quot;failed to apply the new configuration&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sp *scrapePool) reload(cfg *config.ScrapeConfig) error &#123;</span><br><span class="line">	targetScrapePoolReloads.Inc()</span><br><span class="line">	start :&#x3D; time.Now()</span><br><span class="line"></span><br><span class="line">	sp.mtx.Lock()</span><br><span class="line">	defer sp.mtx.Unlock()</span><br><span class="line"></span><br><span class="line">	client, err :&#x3D; config_util.NewClientFromConfig(cfg.HTTPClientConfig, cfg.JobName, false)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		targetScrapePoolReloadsFailed.Inc()</span><br><span class="line">		return errors.Wrap(err, &quot;error creating HTTP client&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	sp.config &#x3D; cfg</span><br><span class="line">	oldClient :&#x3D; sp.client</span><br><span class="line">	sp.client &#x3D; client</span><br><span class="line"></span><br><span class="line">	var (</span><br><span class="line">		wg              sync.WaitGroup</span><br><span class="line">		interval        &#x3D; time.Duration(sp.config.ScrapeInterval)</span><br><span class="line">		timeout         &#x3D; time.Duration(sp.config.ScrapeTimeout)</span><br><span class="line">		limit           &#x3D; int(sp.config.SampleLimit)</span><br><span class="line">		honorLabels     &#x3D; sp.config.HonorLabels</span><br><span class="line">		honorTimestamps &#x3D; sp.config.HonorTimestamps</span><br><span class="line">		mrc             &#x3D; sp.config.MetricRelabelConfigs</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	for fp, oldLoop :&#x3D; range sp.loops &#123;</span><br><span class="line">		var (</span><br><span class="line">			t       &#x3D; sp.activeTargets[fp]</span><br><span class="line">			s       &#x3D; &amp;targetScraper&#123;Target: t, client: sp.client, timeout: timeout&#125;</span><br><span class="line">			newLoop &#x3D; sp.newLoop(scrapeLoopOptions&#123;</span><br><span class="line">				target:          t,</span><br><span class="line">				scraper:         s,</span><br><span class="line">				limit:           limit,</span><br><span class="line">				honorLabels:     honorLabels,</span><br><span class="line">				honorTimestamps: honorTimestamps,</span><br><span class="line">				mrc:             mrc,</span><br><span class="line">			&#125;)</span><br><span class="line">		)</span><br><span class="line">		wg.Add(1)</span><br><span class="line"></span><br><span class="line">		go func(oldLoop, newLoop loop) &#123;</span><br><span class="line">			oldLoop.stop()</span><br><span class="line">			wg.Done()</span><br><span class="line"></span><br><span class="line">			go newLoop.run(interval, timeout, nil)</span><br><span class="line">		&#125;(oldLoop, newLoop)</span><br><span class="line"></span><br><span class="line">		sp.loops[fp] &#x3D; newLoop</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	oldClient.CloseIdleConnections()</span><br><span class="line">	targetReloadIntervalLength.WithLabelValues(interval.String()).Observe(</span><br><span class="line">		time.Since(start).Seconds(),</span><br><span class="line">	)</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<ol>
<li>把解析好的配置，遍历，变为一个jobName为key，配置值为Value的map</li>
<li>对比自己的配置，如果之前已经存在但是配置发生变动的，则去reload scraper pool的配置。</li>
<li>（Reload） 如果需要reload配置的情况下，会重新生成scrapePool后，派生多一个线程去执行scraperPool.Sync()，知道Manager的targetSet被遍历完为止。Sync方法的内容会后面进行详细讲解。</li>
</ol>
<p>Run()方法</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">func (m *Manager) Run(tsets &lt;-chan map[string][]*targetgroup.Group) error &#123;</span><br><span class="line">	go m.reloader()</span><br><span class="line">	for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case ts :&#x3D; &lt;-tsets:</span><br><span class="line">			m.updateTsets(ts)</span><br><span class="line"></span><br><span class="line">			select &#123;</span><br><span class="line">			case m.triggerReload &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class="line">			default:</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		case &lt;-m.graceShut:</span><br><span class="line">			return nil</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (m *Manager) reloader() &#123;</span><br><span class="line">	ticker :&#x3D; time.NewTicker(5 * time.Second)</span><br><span class="line">	defer ticker.Stop()</span><br><span class="line"></span><br><span class="line">	for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;-m.graceShut:</span><br><span class="line">			return</span><br><span class="line">		case &lt;-ticker.C:</span><br><span class="line">			select &#123;</span><br><span class="line">			case &lt;-m.triggerReload:</span><br><span class="line">				m.reload()</span><br><span class="line">			case &lt;-m.graceShut:</span><br><span class="line">				return</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>功能：</p>
<ol>
<li>等待从Main.go中传入的discoveryManager的SyncCh是否有变动，如果有变动，更新Targetset。</li>
<li>派生出了一个Reloader协程，Reloader协程会定时检查是否有关闭的信号或者Reload信号（triggerReload channel,就是外部给与主协程的刺激产生的二级信号），如果有，则执行reload操作。</li>
</ol>

        <h2 id="子协程逻辑"   >
          <a href="#子协程逻辑" class="heading-link"><i class="fas fa-link"></i></a>子协程逻辑</h2>
      
        <h3 id="ScraperPool"   >
          <a href="#ScraperPool" class="heading-link"><i class="fas fa-link"></i></a>ScraperPool</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Sync converts target groups into actual scrape targets and synchronizes</span><br><span class="line">&#x2F;&#x2F; the currently running scraper with the resulting set and returns all scraped and dropped targets.</span><br><span class="line">func (sp *scrapePool) Sync(tgs []*targetgroup.Group) &#123;</span><br><span class="line">	start :&#x3D; time.Now()</span><br><span class="line"></span><br><span class="line">	var all []*Target</span><br><span class="line">	sp.mtx.Lock()</span><br><span class="line">	sp.droppedTargets &#x3D; []*Target&#123;&#125;</span><br><span class="line">	for _, tg :&#x3D; range tgs &#123;</span><br><span class="line">		targets, err :&#x3D; targetsFromGroup(tg, sp.config)</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			level.Error(sp.logger).Log(&quot;msg&quot;, &quot;creating targets failed&quot;, &quot;err&quot;, err)</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		for _, t :&#x3D; range targets &#123;</span><br><span class="line">			if t.Labels().Len() &gt; 0 &#123;</span><br><span class="line">				all &#x3D; append(all, t)</span><br><span class="line">			&#125; else if t.DiscoveredLabels().Len() &gt; 0 &#123;</span><br><span class="line">				sp.droppedTargets &#x3D; append(sp.droppedTargets, t)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sp.mtx.Unlock()</span><br><span class="line">	sp.sync(all)</span><br><span class="line"></span><br><span class="line">	targetSyncIntervalLength.WithLabelValues(sp.config.JobName).Observe(</span><br><span class="line">		time.Since(start).Seconds(),</span><br><span class="line">	)</span><br><span class="line">	targetScrapePoolSyncsCounter.WithLabelValues(sp.config.JobName).Inc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>Sync函数是一个对外暴露函数的接口：</p>
<ol>
<li>把配置解析出来的target结构化。</li>
<li>调用内部方法sync()来进行数据抓取的执行</li>
<li>一些计数器添加计数</li>
</ol>
<p>值得注意的是Append方法，是一个封装了的方法，是同是进行对变量的修改，并且包含了采集到的数据持久化的操作。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; sync takes a list of potentially duplicated targets, deduplicates them, starts</span><br><span class="line">&#x2F;&#x2F; scrape loops for new targets, and stops scrape loops for disappeared targets.</span><br><span class="line">&#x2F;&#x2F; It returns after all stopped scrape loops terminated.</span><br><span class="line">func (sp *scrapePool) sync(targets []*Target) &#123;</span><br><span class="line">	sp.mtx.Lock()</span><br><span class="line">	defer sp.mtx.Unlock()</span><br><span class="line"></span><br><span class="line">	var (</span><br><span class="line">		uniqueTargets   &#x3D; map[uint64]struct&#123;&#125;&#123;&#125;</span><br><span class="line">		interval        &#x3D; time.Duration(sp.config.ScrapeInterval)</span><br><span class="line">		timeout         &#x3D; time.Duration(sp.config.ScrapeTimeout)</span><br><span class="line">		limit           &#x3D; int(sp.config.SampleLimit)</span><br><span class="line">		honorLabels     &#x3D; sp.config.HonorLabels</span><br><span class="line">		honorTimestamps &#x3D; sp.config.HonorTimestamps</span><br><span class="line">		mrc             &#x3D; sp.config.MetricRelabelConfigs</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	for _, t :&#x3D; range targets &#123;</span><br><span class="line">		t :&#x3D; t</span><br><span class="line">		hash :&#x3D; t.hash()</span><br><span class="line">		uniqueTargets[hash] &#x3D; struct&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">		if _, ok :&#x3D; sp.activeTargets[hash]; !ok &#123;</span><br><span class="line">			s :&#x3D; &amp;targetScraper&#123;Target: t, client: sp.client, timeout: timeout&#125;</span><br><span class="line">			l :&#x3D; sp.newLoop(scrapeLoopOptions&#123;</span><br><span class="line">				target:          t,</span><br><span class="line">				scraper:         s,</span><br><span class="line">				limit:           limit,</span><br><span class="line">				honorLabels:     honorLabels,</span><br><span class="line">				honorTimestamps: honorTimestamps,</span><br><span class="line">				mrc:             mrc,</span><br><span class="line">			&#125;)</span><br><span class="line"></span><br><span class="line">			sp.activeTargets[hash] &#x3D; t</span><br><span class="line">			sp.loops[hash] &#x3D; l</span><br><span class="line"></span><br><span class="line">			go l.run(interval, timeout, nil)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			&#x2F;&#x2F; Need to keep the most updated labels information</span><br><span class="line">			&#x2F;&#x2F; for displaying it in the Service Discovery web page.</span><br><span class="line">			sp.activeTargets[hash].SetDiscoveredLabels(t.DiscoveredLabels())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Stop and remove old targets and scraper loops.</span><br><span class="line">	for hash :&#x3D; range sp.activeTargets &#123;</span><br><span class="line">		if _, ok :&#x3D; uniqueTargets[hash]; !ok &#123;</span><br><span class="line">			wg.Add(1)</span><br><span class="line">			go func(l loop) &#123;</span><br><span class="line"></span><br><span class="line">				l.stop()</span><br><span class="line"></span><br><span class="line">				wg.Done()</span><br><span class="line">			&#125;(sp.loops[hash])</span><br><span class="line"></span><br><span class="line">			delete(sp.loops, hash)</span><br><span class="line">			delete(sp.activeTargets, hash)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Wait for all potentially stopped scrapers to terminate.</span><br><span class="line">	&#x2F;&#x2F; This covers the case of flapping targets. If the server is under high load, a new scraper</span><br><span class="line">	&#x2F;&#x2F; may be active and tries to insert. The old scraper that didn&#39;t terminate yet could still</span><br><span class="line">	&#x2F;&#x2F; be inserting a previous sample set.</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>主要逻辑：</p>
<ol>
<li>把传入的Target列表进行遍历<br>1.1 如果target不在active的map中， 生成targetScraper，然后把targetScraper放入Loop里面，调用Loop.run()在协程中进行逻辑<br>1.2 否则， 会先删除旧的协程，然后重新生成协程。</li>
</ol>

        <h3 id="ScraperLoop"   >
          <a href="#ScraperLoop" class="heading-link"><i class="fas fa-link"></i></a>ScraperLoop</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">func (sl *scrapeLoop) run(interval, timeout time.Duration, errc chan&lt;- error) &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	case &lt;-time.After(sl.scraper.offset(interval, sl.jitterSeed)):</span><br><span class="line">		&#x2F;&#x2F; Continue after a scraping offset.</span><br><span class="line">	case &lt;-sl.ctx.Done():</span><br><span class="line">		close(sl.stopped)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var last time.Time</span><br><span class="line"></span><br><span class="line">	ticker :&#x3D; time.NewTicker(interval)</span><br><span class="line">	defer ticker.Stop()</span><br><span class="line"></span><br><span class="line">mainLoop:</span><br><span class="line">	for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;-sl.parentCtx.Done():</span><br><span class="line">			close(sl.stopped)</span><br><span class="line">			return</span><br><span class="line">		case &lt;-sl.ctx.Done():</span><br><span class="line">			break mainLoop</span><br><span class="line">		default:</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		var (</span><br><span class="line">			start             &#x3D; time.Now()</span><br><span class="line">			scrapeCtx, cancel &#x3D; context.WithTimeout(sl.ctx, timeout)</span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Only record after the first scrape.</span><br><span class="line">		if !last.IsZero() &#123;</span><br><span class="line">			targetIntervalLength.WithLabelValues(interval.String()).Observe(</span><br><span class="line">				time.Since(last).Seconds(),</span><br><span class="line">			)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		b :&#x3D; sl.buffers.Get(sl.lastScrapeSize).([]byte)</span><br><span class="line">		buf :&#x3D; bytes.NewBuffer(b)</span><br><span class="line"></span><br><span class="line">		contentType, scrapeErr :&#x3D; sl.scraper.scrape(scrapeCtx, buf)</span><br><span class="line">		cancel()</span><br><span class="line"></span><br><span class="line">		if scrapeErr &#x3D;&#x3D; nil &#123;</span><br><span class="line">			b &#x3D; buf.Bytes()</span><br><span class="line">			&#x2F;&#x2F; NOTE: There were issues with misbehaving clients in the past</span><br><span class="line">			&#x2F;&#x2F; that occasionally returned empty results. We don&#39;t want those</span><br><span class="line">			&#x2F;&#x2F; to falsely reset our buffer size.</span><br><span class="line">			if len(b) &gt; 0 &#123;</span><br><span class="line">				sl.lastScrapeSize &#x3D; len(b)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			level.Debug(sl.l).Log(&quot;msg&quot;, &quot;Scrape failed&quot;, &quot;err&quot;, scrapeErr.Error())</span><br><span class="line">			if errc !&#x3D; nil &#123;</span><br><span class="line">				errc &lt;- scrapeErr</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; A failed scrape is the same as an empty scrape,</span><br><span class="line">		&#x2F;&#x2F; we still call sl.append to trigger stale markers.</span><br><span class="line">		total, added, seriesAdded, appErr :&#x3D; sl.append(b, contentType, start)</span><br><span class="line">		if appErr !&#x3D; nil &#123;</span><br><span class="line">			level.Warn(sl.l).Log(&quot;msg&quot;, &quot;append failed&quot;, &quot;err&quot;, appErr)</span><br><span class="line">			&#x2F;&#x2F; The append failed, probably due to a parse error or sample limit.</span><br><span class="line">			&#x2F;&#x2F; Call sl.append again with an empty scrape to trigger stale markers.</span><br><span class="line">			if _, _, _, err :&#x3D; sl.append([]byte&#123;&#125;, &quot;&quot;, start); err !&#x3D; nil &#123;</span><br><span class="line">				level.Warn(sl.l).Log(&quot;msg&quot;, &quot;append failed&quot;, &quot;err&quot;, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sl.buffers.Put(b)</span><br><span class="line"></span><br><span class="line">		if scrapeErr &#x3D;&#x3D; nil &#123;</span><br><span class="line">			scrapeErr &#x3D; appErr</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if err :&#x3D; sl.report(start, time.Since(start), total, added, seriesAdded, scrapeErr); err !&#x3D; nil &#123;</span><br><span class="line">			level.Warn(sl.l).Log(&quot;msg&quot;, &quot;appending scrape report failed&quot;, &quot;err&quot;, err)</span><br><span class="line">		&#125;</span><br><span class="line">		last &#x3D; start</span><br><span class="line"></span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;-sl.parentCtx.Done():</span><br><span class="line">			close(sl.stopped)</span><br><span class="line">			return</span><br><span class="line">		case &lt;-sl.ctx.Done():</span><br><span class="line">			break mainLoop</span><br><span class="line">		case &lt;-ticker.C:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(sl.stopped)</span><br><span class="line"></span><br><span class="line">	sl.endOfRunStaleness(last, ticker, interval)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>ScraperLoop是单个Target进行获取的执行单位，协程使用死循环进行占用，然后调用scraper接口的Scrape方法去抓取数据，并且调用Stroage模块的Appender的接口金属数据的持久化，然后继续定时休眠的过程。我们需要更加具体的看一下实例Scraper的Scrape方法。</p>
<p>ScraperLoop把Scraper抽象出来的三个接口都进行了调用：</p>
<ol>
<li>开始部分的Select代码段中的Offset是用于控制第一次执行的时候等待的间隔</li>
<li>Scrape方法就是直接进行数据的抓取，下面有详细解析</li>
<li>report方法，修改Scraper中Target自己保存的状态。</li>
</ol>

        <h3 id="TargerScraper"   >
          <a href="#TargerScraper" class="heading-link"><i class="fas fa-link"></i></a>TargerScraper</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">func (s *targetScraper) scrape(ctx context.Context, w io.Writer) (string, error) &#123;</span><br><span class="line">	if s.req &#x3D;&#x3D; nil &#123;</span><br><span class="line">		req, err :&#x3D; http.NewRequest(&quot;GET&quot;, s.URL().String(), nil)</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			return &quot;&quot;, err</span><br><span class="line">		&#125;</span><br><span class="line">		req.Header.Add(&quot;Accept&quot;, acceptHeader)</span><br><span class="line">		req.Header.Add(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)</span><br><span class="line">		req.Header.Set(&quot;User-Agent&quot;, userAgentHeader)</span><br><span class="line">		req.Header.Set(&quot;X-Prometheus-Scrape-Timeout-Seconds&quot;, fmt.Sprintf(&quot;%f&quot;, s.timeout.Seconds()))</span><br><span class="line"></span><br><span class="line">		s.req &#x3D; req</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resp, err :&#x3D; s.client.Do(s.req.WithContext(ctx))</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		return &quot;&quot;, err</span><br><span class="line">	&#125;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		io.Copy(ioutil.Discard, resp.Body)</span><br><span class="line">		resp.Body.Close()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	if resp.StatusCode !&#x3D; http.StatusOK &#123;</span><br><span class="line">		return &quot;&quot;, errors.Errorf(&quot;server returned HTTP status %s&quot;, resp.Status)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if resp.Header.Get(&quot;Content-Encoding&quot;) !&#x3D; &quot;gzip&quot; &#123;</span><br><span class="line">		_, err &#x3D; io.Copy(w, resp.Body)</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			return &quot;&quot;, err</span><br><span class="line">		&#125;</span><br><span class="line">		return resp.Header.Get(&quot;Content-Type&quot;), nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if s.gzipr &#x3D;&#x3D; nil &#123;</span><br><span class="line">		s.buf &#x3D; bufio.NewReader(resp.Body)</span><br><span class="line">		s.gzipr, err &#x3D; gzip.NewReader(s.buf)</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			return &quot;&quot;, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		s.buf.Reset(resp.Body)</span><br><span class="line">		if err &#x3D; s.gzipr.Reset(s.buf); err !&#x3D; nil &#123;</span><br><span class="line">			return &quot;&quot;, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err &#x3D; io.Copy(w, s.gzipr)</span><br><span class="line">	s.gzipr.Close()</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		return &quot;&quot;, err</span><br><span class="line">	&#125;</span><br><span class="line">	return resp.Header.Get(&quot;Content-Type&quot;), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>Scrape方法是使用HttpClient进行对target url 的数据抓取，抓取的内容在context中进行传递，得到返回后，继续解析，返回给ScraperLoop的Run方法使用。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/10/05/prometheus-service-discovery/">Prometheus服务发现源码阅读</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-01-22</span></span></div></header><div class="post-body"><div class="post-excerpt"><!-- ---
layout: post
title: Prometheus服务发现源码阅读
author: Ray Chan(ray1888)
date: '2019-10-05 20:51:38 +0800'
category: Prometheus
summary: Prometheus Service Discovery Module
thumbnail: Prometheus.png
--- -->


        <h1 id="目录"   >
          <a href="#目录" class="heading-link"><i class="fas fa-link"></i></a>目录</h1>
      <ol>
<li>使用的目的  </li>
<li>代码实现<br>2.1 主协程逻辑<br>2.2 子协程逻辑</li>
</ol>

        <h1 id="代码版本"   >
          <a href="#代码版本" class="heading-link"><i class="fas fa-link"></i></a>代码版本</h1>
      <p>基于 prometheus项目的master branch的5a554df0855bf707a8c333c0dd830067d03422cf commit</p>

        <h1 id="使用目的"   >
          <a href="#使用目的" class="heading-link"><i class="fas fa-link"></i></a>使用目的</h1>
      <p>服务发现是Prometheus中最重要的功能之一，因为它是支撑Prometheus可以在容器的环境下的最重要的功能。因为应用的容器部署的弹性和有效的时长远与传统的基于服务器（无论是实体机还是虚拟机[OpenStack]这一类的机器）部署， 都会变动的更加快。因此为了适应这种弹性大、变化快的环境，它需要基于不同平台来支持服务发现这个功能。</p>
<p>Prometheus的服务发现模块是在prometheus/discovery的目录下面，它在Prometheus中的体系支撑了采集器的发现和AlertManager的发现。<br>可以看下面的代码。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  此代码在cmd&#x2F;main.go中的 350-352行</span><br><span class="line">	ctxScrape, cancelScrape &#x3D; context.WithCancel(context.Background())</span><br><span class="line">	discoveryManagerScrape  &#x3D; discovery.NewManager(ctxScrape, log.With(logger, &quot;component&quot;, &quot;discovery manager scrape&quot;), discovery.Name(&quot;scrape&quot;))</span><br><span class="line"></span><br><span class="line">	ctxNotify, cancelNotify &#x3D; context.WithCancel(context.Background())</span><br><span class="line">	discoveryManagerNotify  &#x3D; discovery.NewManager(ctxNotify, log.With(logger, &quot;component&quot;, &quot;discovery manager notify&quot;), discovery.Name(&quot;notify&quot;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  具体注入到两个功能的使用</span><br><span class="line">&#x2F;* </span><br><span class="line">	cmd&#x2F;main.go line 555, 把Manager的输出的信道传递给scrapeManager，然后后面就会去restore scrape的方式。</span><br><span class="line">	后面会有单独文章写Scrape（抓取数据）的部分</span><br><span class="line">	*&#x2F;</span><br><span class="line">err :&#x3D; scrapeManager.Run(discoveryManagerScrape.SyncCh())</span><br><span class="line"></span><br><span class="line">&#x2F;* </span><br><span class="line">	cmd&#x2F;main.go line 726, 把Manager的输出的信道传递给notifierManager，然后后面就会去获取更新alertManager组件的方式。</span><br><span class="line">	后面会有单独文章写Notifer（抓取数据）的部分</span><br><span class="line">	*&#x2F;</span><br><span class="line">notifierManager.Run(discoveryManagerNotify.SyncCh())</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在main.go line 735, run Group 会执行上面注册在g 里面的这两个discoveryManager的Run方法。</span><br></pre></td></tr></table></div></figure>
<p>所以整体的代码执行的入口流程</p>
<ol>
<li>在main.go实例化两个discoveryManager来进行服务发现的操作</li>
<li>把注入的discovery config进行解析，并且生成对应的Provider协程</li>
<li>主协程执行上面两个discoveryManager的Run方法</li>
</ol>

        <h1 id="代码实现"   >
          <a href="#代码实现" class="heading-link"><i class="fas fa-link"></i></a>代码实现</h1>
      
        <h2 id="模块的运行逻辑图"   >
          <a href="#模块的运行逻辑图" class="heading-link"><i class="fas fa-link"></i></a>模块的运行逻辑图</h2>
      <!-- ![ServiceDiscoveryModule](/assets/img/posts/prometheus/DiscoverManager.png) -->



        <h2 id="主协程的逻辑"   >
          <a href="#主协程的逻辑" class="heading-link"><i class="fas fa-link"></i></a>主协程的逻辑</h2>
      <ol>
<li>先去读取服务发现相关的配置，调用ApplyConfig()读取存在的service discovery的方式，并且加载到NewManager的结构体中。可以同同时支持多个service Discovery的方式。使用add函数把配置变为Providers结构体。<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">add :&#x3D; func(cfg interface&#123;&#125;, newDiscoverer func() (Discoverer, error)) &#123;</span><br><span class="line">		t :&#x3D; reflect.TypeOf(cfg).String()</span><br><span class="line">		for _, p :&#x3D; range m.providers &#123;</span><br><span class="line">			if reflect.DeepEqual(cfg, p.config) &#123;</span><br><span class="line">				p.subs &#x3D; append(p.subs, setName)</span><br><span class="line">				added &#x3D; true</span><br><span class="line">				return</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		d, err :&#x3D; newDiscoverer()</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			level.Error(m.logger).Log(&quot;msg&quot;, &quot;Cannot create service discovery&quot;, &quot;err&quot;, err, &quot;type&quot;, t)</span><br><span class="line">			failedCount++</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		provider :&#x3D; provider&#123;</span><br><span class="line">			name:   fmt.Sprintf(&quot;%s&#x2F;%d&quot;, t, len(m.providers)),</span><br><span class="line">			d:      d,</span><br><span class="line">			config: cfg,</span><br><span class="line">			subs:   []string&#123;setName&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">		m.providers &#x3D; append(m.providers, &amp;provider)</span><br><span class="line">		added &#x3D; true</span><br><span class="line">	&#125;</span><br><span class="line">&#x2F;&#x2F; 支持多种方式的配置 具体可以看代码的discovery&#x2F;manager.go 356-417行</span><br></pre></td></tr></table></div></figure></li>
<li>然后为每个Provider生成两个协程去进行服务发现的功能。 <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; discovery&#x2F;manager.go line 223-226</span><br><span class="line">func (m *Manager) startProvider(ctx context.Context, p *provider) &#123;</span><br><span class="line">	level.Debug(m.logger).Log(&quot;msg&quot;, &quot;Starting provider&quot;, &quot;provider&quot;, p.name, &quot;subs&quot;, fmt.Sprintf(&quot;%v&quot;, p.subs))</span><br><span class="line">	ctx, cancel :&#x3D; context.WithCancel(ctx)</span><br><span class="line">	&#x2F;&#x2F; 此处Update是执行协程与主协程的交流通道，传输Watch的变动</span><br><span class="line">	updates :&#x3D; make(chan []*targetgroup.Group)</span><br><span class="line">	m.discoverCancel &#x3D; append(m.discoverCancel, cancel)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;  执行服务发现的Watch</span><br><span class="line">	go p.d.Run(ctx, updates)</span><br><span class="line">	&#x2F;&#x2F; 把每个协程生成的updates放入到Manager中，使得子协程中发现到服务的变动的时候可以通知到主协程</span><br><span class="line">	go m.updater(ctx, p, updates)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; discovery&#x2F;manager.go line 205-207</span><br><span class="line">for _, prov :&#x3D; range m.providers &#123;</span><br><span class="line">		m.startProvider(m.ctx, prov)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
ApplyConfig完成后，Run方法如下<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func (m *Manager) Run() error &#123;</span><br><span class="line">	go m.sender()</span><br><span class="line">	for range m.ctx.Done() &#123;</span><br><span class="line">		m.cancelDiscoverers()</span><br><span class="line">		return m.ctx.Err()</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
Manager会派生多一个协程去定时检查配置的变动，本质上是检查上面派生的updater协程时候有传入信号到triggerchan中,主协程就是为了防止泄露一直去遍历context的是否done，保持主协程阻塞，维持这个模块的运行。我们主要看一下Manager.Updater()和Manager.Sender()这两个函数。</li>
</ol>
<p>此处 Manager.trigglechan is 长度为1的buffered channel。updates := make(chan []*targetgroup.Group), 是unbuffered channel </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">func (m *Manager) updater(ctx context.Context, p *provider, updates chan []*targetgroup.Group) &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;-ctx.Done():</span><br><span class="line">			return</span><br><span class="line">		case tgs, ok :&#x3D; &lt;-updates:</span><br><span class="line">			receivedUpdates.WithLabelValues(m.name).Inc()</span><br><span class="line">			if !ok &#123;</span><br><span class="line">				level.Debug(m.logger).Log(&quot;msg&quot;, &quot;discoverer channel closed&quot;, &quot;provider&quot;, p.name)</span><br><span class="line">				return</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			for _, s :&#x3D; range p.subs &#123;</span><br><span class="line">				m.updateGroup(poolKey&#123;setName: s, provider: p.name&#125;, tgs)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			select &#123;</span><br><span class="line">			case m.triggerSend &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class="line">			default:</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *Manager) sender() &#123;</span><br><span class="line">	ticker :&#x3D; time.NewTicker(m.updatert)</span><br><span class="line">	defer ticker.Stop()</span><br><span class="line"></span><br><span class="line">	for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;-m.ctx.Done():</span><br><span class="line">			return</span><br><span class="line">		case &lt;-ticker.C: &#x2F;&#x2F; Some discoverers send updates too often so we throttle these with the ticker.</span><br><span class="line">			select &#123;</span><br><span class="line">			case &lt;-m.triggerSend:</span><br><span class="line">				sentUpdates.WithLabelValues(m.name).Inc()</span><br><span class="line">				select &#123;</span><br><span class="line">				case m.syncCh &lt;- m.allGroups():</span><br><span class="line">				default:</span><br><span class="line">					delayedUpdates.WithLabelValues(m.name).Inc()</span><br><span class="line">					level.Debug(m.logger).Log(&quot;msg&quot;, &quot;discovery receiver&#39;s channel was full so will retry the next cycle&quot;)</span><br><span class="line">					select &#123;</span><br><span class="line">					case m.triggerSend &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class="line">					default:</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			default:</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>步骤</p>
<ol>
<li>Provider 传入变化了的update到update channel中</li>
<li>Manager.Updater协程收集到了变化的内容后，修改Manager里面Group的内容。塞入信号到triggerSend channel中</li>
<li>Manager.Sender协程定时去进行获取通知，检查到triggerSend Channel中可以获取之后，就会尝试塞到syncCh中，使得订阅者可以收到这个消息。(即Main里面的两个放入syncCh方法的ScrapeManager和NotiferManager可以收到)</li>
</ol>
<p>然后整个的流程就是这样</p>

        <h2 id="派生协程的逻辑"   >
          <a href="#派生协程的逻辑" class="heading-link"><i class="fas fa-link"></i></a>派生协程的逻辑</h2>
      
        <h3 id="Provider协程的逻辑"   >
          <a href="#Provider协程的逻辑" class="heading-link"><i class="fas fa-link"></i></a>Provider协程的逻辑</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Discoverer interface &#123;</span><br><span class="line">	&#x2F;&#x2F; Run hands a channel to the discovery provider (Consul, DNS etc) through which it can send</span><br><span class="line">	&#x2F;&#x2F; updated target groups.</span><br><span class="line">	&#x2F;&#x2F; Must returns if the context gets canceled. It should not close the update</span><br><span class="line">	&#x2F;&#x2F; channel on returning.</span><br><span class="line">	Run(ctx context.Context, up chan&lt;- []*targetgroup.Group)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>Provider协程主要时根据具体注入的配置来生成出与对应的系统进行服务发现的能力。每个Provider中的Discoverer都实现了自己对应的Run方法即上面p.d.Run()的方法。（如何生成上面已经描述，此处不再复述）</p>
<p>下面我们简单的看一下其中两个Provider，基于配置文件的Provider和基于zookeeper的Provider来看看具体的流程是怎样处理的。<br>对于Provider，我们可以理解为一个watch&amp;notify的模型，但是是基于不同平台给予的Api继续watch&amp;notify的操作。</p>

        <h4 id="FileProvider执行"   >
          <a href="#FileProvider执行" class="heading-link"><i class="fas fa-link"></i></a>FileProvider执行</h4>
      <p>FileProvider支持解析json和yaml的格式内容  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; discovery&#x2F;file&#x2F;file.go line 39-46</span><br><span class="line">var (</span><br><span class="line">	patFileSDName &#x3D; regexp.MustCompile(&#96;^[^*]*(\*[^&#x2F;]*)?\.(json|yml|yaml|JSON|YML|YAML)$&#96;)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; DefaultSDConfig is the default file SD configuration.</span><br><span class="line">	DefaultSDConfig &#x3D; SDConfig&#123;</span><br><span class="line">		RefreshInterval: model.Duration(5 * time.Minute),</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>
<p>下面我们看看主要实现Discoverer的Run方法的逻辑</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">func (d *Discovery) Run(ctx context.Context, ch chan&lt;- []*targetgroup.Group) &#123;</span><br><span class="line">	watcher, err :&#x3D; fsnotify.NewWatcher()</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		level.Error(d.logger).Log(&quot;msg&quot;, &quot;Error adding file watcher&quot;, &quot;err&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	d.watcher &#x3D; watcher</span><br><span class="line">	defer d.stop()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;  协程内第一次执行把conf添加到discoverer中</span><br><span class="line">	d.refresh(ctx, ch)</span><br><span class="line"></span><br><span class="line">	ticker :&#x3D; time.NewTicker(d.interval)</span><br><span class="line">	defer ticker.Stop()</span><br><span class="line"></span><br><span class="line">	for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;-ctx.Done():</span><br><span class="line">			return</span><br><span class="line"></span><br><span class="line">		case event :&#x3D; &lt;-d.watcher.Events:</span><br><span class="line">			&#x2F;&#x2F; fsnotify sometimes sends a bunch of events without name or operation.</span><br><span class="line">			&#x2F;&#x2F; It&#39;s unclear what they are and why they are sent - filter them out.</span><br><span class="line">			if len(event.Name) &#x3D;&#x3D; 0 &#123;</span><br><span class="line">				break</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F; Everything but a chmod requires rereading.</span><br><span class="line">			if event.Op^fsnotify.Chmod &#x3D;&#x3D; 0 &#123;</span><br><span class="line">				break</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F; Changes to a file can spawn various sequences of events with</span><br><span class="line">			&#x2F;&#x2F; different combinations of operations. For all practical purposes</span><br><span class="line">			&#x2F;&#x2F; this is inaccurate.</span><br><span class="line">			&#x2F;&#x2F; The most reliable solution is to reload everything if anything happens.</span><br><span class="line">			d.refresh(ctx, ch)</span><br><span class="line"></span><br><span class="line">		case &lt;-ticker.C:</span><br><span class="line">			&#x2F;&#x2F; Setting a new watch after an update might fail. Make sure we don&#39;t lose</span><br><span class="line">			&#x2F;&#x2F; those files forever.</span><br><span class="line">			d.refresh(ctx, ch)</span><br><span class="line"></span><br><span class="line">		case err :&#x3D; &lt;-d.watcher.Errors:</span><br><span class="line">			if err !&#x3D; nil &#123;</span><br><span class="line">				level.Error(d.logger).Log(&quot;msg&quot;, &quot;Error watching file&quot;, &quot;err&quot;, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>上面的死循环可以看出，对于File Discoverer， 它支持两种的Watch的方式，一个是定时监控(ticker.C)，一个是事件触发监控（event := &lt;-d.watcher.Events)。</p>
<p>所以重点是在于Refresh函数，本质上就是一个重新解析并且检查文件内容是否有变动的函数，解析完文件之后就可以传出配置到对应的update channel中。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">func (d *Discovery) refresh(ctx context.Context, ch chan&lt;- []*targetgroup.Group) &#123;</span><br><span class="line">	t0 :&#x3D; time.Now()</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		fileSDScanDuration.Observe(time.Since(t0).Seconds())</span><br><span class="line">	&#125;()</span><br><span class="line">	ref :&#x3D; map[string]int&#123;&#125;</span><br><span class="line">	&#x2F;&#x2F; 把初始化传入的配置的路径进行检查</span><br><span class="line">	for _, p :&#x3D; range d.listFiles() &#123;</span><br><span class="line">		&#x2F;&#x2F;  把单个文件进行解析，获取出里面的targets</span><br><span class="line">		tgroups, err :&#x3D; d.readFile(p)</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			fileSDReadErrorsCount.Inc()</span><br><span class="line"></span><br><span class="line">			level.Error(d.logger).Log(&quot;msg&quot;, &quot;Error reading file&quot;, &quot;path&quot;, p, &quot;err&quot;, err)</span><br><span class="line">			&#x2F;&#x2F; Prevent deletion down below.</span><br><span class="line">			ref[p] &#x3D; d.lastRefresh[p]</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		select &#123;</span><br><span class="line">			&#x2F;&#x2F; 把新传入的传入到Update中</span><br><span class="line">		case ch &lt;- tgroups:</span><br><span class="line">		case &lt;-ctx.Done():</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ref[p] &#x3D; len(tgroups)</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; Send empty updates for sources that disappeared.</span><br><span class="line">	for f, n :&#x3D; range d.lastRefresh &#123;</span><br><span class="line">		m, ok :&#x3D; ref[f]</span><br><span class="line">		if !ok || n &gt; m &#123;</span><br><span class="line">			level.Debug(d.logger).Log(&quot;msg&quot;, &quot;file_sd refresh found file that should be removed&quot;, &quot;file&quot;, f)</span><br><span class="line">			d.deleteTimestamp(f)</span><br><span class="line">			for i :&#x3D; m; i &lt; n; i++ &#123;</span><br><span class="line">				select &#123;</span><br><span class="line">				case ch &lt;- []*targetgroup.Group&#123;&#123;Source: fileSource(f, i)&#125;&#125;:</span><br><span class="line">				case &lt;-ctx.Done():</span><br><span class="line">					return</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	d.lastRefresh &#x3D; ref</span><br><span class="line"></span><br><span class="line">	d.watchFiles()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="zookeeperProvider执行"   >
          <a href="#zookeeperProvider执行" class="heading-link"><i class="fas fa-link"></i></a>zookeeperProvider执行</h4>
      <p>Zookeeper的Provider与上面的模式类似，差别在于：</p>
<ol>
<li>初始化的时候需要创建zookeeper的链接（配置中需要传入配置好zookeeper相关的配置）</li>
<li>分为了ServerSetPoint和NerveEndPoint两个类型的Discovery，因此抽象了一个Discovery的结构体</li>
<li>没有了定时检查（因为不存在文件系统问题的）这种检查的方式</li>
</ol>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">type Discovery struct &#123;</span><br><span class="line">	conn *zk.Conn</span><br><span class="line"></span><br><span class="line">	sources map[string]*targetgroup.Group</span><br><span class="line"></span><br><span class="line">	updates     chan treecache.ZookeeperTreeCacheEvent</span><br><span class="line">	pathUpdates []chan treecache.ZookeeperTreeCacheEvent</span><br><span class="line">	treeCaches  []*treecache.ZookeeperTreeCache</span><br><span class="line"></span><br><span class="line">	parse  func(data []byte, path string) (model.LabelSet, error)</span><br><span class="line">	logger log.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Discovery) Run(ctx context.Context, ch chan&lt;- []*targetgroup.Group) &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		for _, tc :&#x3D; range d.treeCaches &#123;</span><br><span class="line">			tc.Stop()</span><br><span class="line">		&#125;</span><br><span class="line">		for _, pathUpdate :&#x3D; range d.pathUpdates &#123;</span><br><span class="line">			&#x2F;&#x2F; Drain event channel in case the treecache leaks goroutines otherwise.</span><br><span class="line">			for range pathUpdate &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		d.conn.Close()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	for _, pathUpdate :&#x3D; range d.pathUpdates &#123;</span><br><span class="line">		go func(update chan treecache.ZookeeperTreeCacheEvent) &#123;</span><br><span class="line">			for event :&#x3D; range update &#123;</span><br><span class="line">				select &#123;</span><br><span class="line">				case d.updates &lt;- event:</span><br><span class="line">				case &lt;-ctx.Done():</span><br><span class="line">					return</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(pathUpdate)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;-ctx.Done():</span><br><span class="line">			return</span><br><span class="line">		case event :&#x3D; &lt;-d.updates:</span><br><span class="line">			tg :&#x3D; &amp;targetgroup.Group&#123;</span><br><span class="line">				Source: event.Path,</span><br><span class="line">			&#125;</span><br><span class="line">			if event.Data !&#x3D; nil &#123;</span><br><span class="line">				labelSet, err :&#x3D; d.parse(*event.Data, event.Path)</span><br><span class="line">				if err &#x3D;&#x3D; nil &#123;</span><br><span class="line">					tg.Targets &#x3D; []model.LabelSet&#123;labelSet&#125;</span><br><span class="line">					d.sources[event.Path] &#x3D; tg</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					delete(d.sources, event.Path)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				delete(d.sources, event.Path)</span><br><span class="line">			&#125;</span><br><span class="line">			select &#123;</span><br><span class="line">			case &lt;-ctx.Done():</span><br><span class="line">				return</span><br><span class="line">			case ch &lt;- []*targetgroup.Group&#123;tg&#125;:</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>Run的流程</p>
<ol>
<li>给每一个需要检查的路径派生一个协程</li>
<li>死循环获取是否有更新</li>
<li>如果有，则使用传入的parse函数去进行解析，然后把结果发送到update的channel中，即ch变量中</li>
</ol>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/09/16/effective-go/">Effective Go Reading</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-09-16</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-01-22</span></span></div></header><div class="post-body"><div class="post-excerpt"><!-- --- -->
<!-- layout: post
title: Effective Go Reading
author: Ray Chan(ray1888)
date: '2019-09-16 11:07:38 +0800'
category: go
summary: Effective Go 
thumbnail: go.png
--- -->

<p>本文章的目的是为了详细阅读和理解Effective GO所提及到的内容。</p>

        <h1 id="目录"   >
          <a href="#目录" class="heading-link"><i class="fas fa-link"></i></a>目录</h1>
      <ol>
<li><a href="#Method">Method</a><br>1.1 <a href="#PvV">Pointers vs Values</a>  </li>
<li><a href="#Data">Data</a><br>2.1 <a href="#NewMake">New vs Make</a><br>2.2 <a href="#Array">Array</a><br>2.3 <a href="#Slice">Slice</a><br>2.4 <a href="#Map">Map</a><br>2.5 <a href="#Append">Append</a>  </li>
<li><a href="#InterFace">Interface</a></li>
<li><a href="#Error">Error</a></li>
<li><a href="#Init">PackageInit</a>  </li>
<li><a href="#Defer">Defer</a></li>
<li><a href="#ShareNote">ShareNote</a></li>
</ol>

        <h1 id="Method"   >
          <a href="#Method" class="heading-link"><i class="fas fa-link"></i></a>Method</h1>
      
        <h2 id="Pointers-vs-Values"   >
          <a href="#Pointers-vs-Values" class="heading-link"><i class="fas fa-link"></i></a>Pointers vs Values</h2>
      <p>主要的区别，如果方法是放在类型值上面而不是指针上面的，可以通过指针和普通类型来进行使用。但是对于方法绑定的是指针的类型，只能通过指针来进行使用。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type ByteSlice []byte</span><br><span class="line"></span><br><span class="line">func (slice ByteSlice) Append(data []byte) []byte &#123;</span><br><span class="line">	&#x2F;&#x2F; Body exactly the same as the Append function defined above.</span><br><span class="line">	l :&#x3D; len(slice)</span><br><span class="line">	if l+len(data) &gt; cap(slice) &#123; &#x2F;&#x2F; reallocate</span><br><span class="line">		&#x2F;&#x2F; Allocate double what&#39;s needed, for future growth.</span><br><span class="line">		newSlice :&#x3D; make([]byte, (l+len(data))*2)</span><br><span class="line">		&#x2F;&#x2F; The copy function is predeclared and works for any slice type.</span><br><span class="line">		copy(newSlice, slice)</span><br><span class="line">		slice &#x3D; newSlice</span><br><span class="line">	&#125;</span><br><span class="line">	slice &#x3D; slice[0 : l+len(data)]</span><br><span class="line">	copy(slice[l:], data)</span><br><span class="line">	return slice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *ByteSlice) Append2(data []byte) &#123;</span><br><span class="line">	slice :&#x3D; *p</span><br><span class="line">	&#x2F;&#x2F; Body as above, without the return.</span><br><span class="line">	l :&#x3D; len(slice)</span><br><span class="line">	if l+len(data) &gt; cap(slice) &#123; &#x2F;&#x2F; reallocate</span><br><span class="line">		&#x2F;&#x2F; Allocate double what&#39;s needed, for future growth.</span><br><span class="line">		newSlice :&#x3D; make([]byte, (l+len(data))*2)</span><br><span class="line">		&#x2F;&#x2F; The copy function is predeclared and works for any slice type.</span><br><span class="line">		copy(newSlice, slice)</span><br><span class="line">		slice &#x3D; newSlice</span><br><span class="line">	&#125;</span><br><span class="line">	slice &#x3D; slice[0 : l+len(data)]</span><br><span class="line">	copy(slice[l:], data)</span><br><span class="line">	*p &#x3D; slice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *ByteSlice) Write(data []byte) (n int, err error) &#123;</span><br><span class="line">	slice :&#x3D; *p</span><br><span class="line">	&#x2F;&#x2F; Body as above, without the return.</span><br><span class="line">	l :&#x3D; len(slice)</span><br><span class="line">	if l+len(data) &gt; cap(slice) &#123; &#x2F;&#x2F; reallocate</span><br><span class="line">		&#x2F;&#x2F; Allocate double what&#39;s needed, for future growth.</span><br><span class="line">		newSlice :&#x3D; make([]byte, (l+len(data))*2)</span><br><span class="line">		&#x2F;&#x2F; The copy function is predeclared and works for any slice type.</span><br><span class="line">		copy(newSlice, slice)</span><br><span class="line">		slice &#x3D; newSlice</span><br><span class="line">	&#125;</span><br><span class="line">	slice &#x3D; slice[0 : l+len(data)]</span><br><span class="line">	copy(slice[l:], data)</span><br><span class="line">	*p &#x3D; slice</span><br><span class="line">	*p &#x3D; slice</span><br><span class="line">	return len(data), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var b ByteSlice</span><br><span class="line">	b &#x3D; b.Append([]byte&#123;1, 2, 3&#125;)</span><br><span class="line">	fmt.Printf(&quot;byteSlice 1 is %v&quot;, b)</span><br><span class="line">	b.Write([]byte&#123;7, 8, 9&#125;)</span><br><span class="line">	fmt.Printf(&quot;byteSlice 2 is %v&quot;, b)</span><br><span class="line">    &#x2F;*</span><br><span class="line">    func Fprintf(w io.Writer, format string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">    *&#x2F;</span><br><span class="line">	fmt.Fprintf(&amp;b, &quot;This hour has %d days\n&quot;, 7)</span><br><span class="line">    &#x2F;*</span><br><span class="line">    if use below code , will throw error </span><br><span class="line">    fmt.Fprintf(b, &quot;This hour has %d days\n&quot;, 7)</span><br><span class="line">    *&#x2F;</span><br><span class="line">	b.Append2([]byte&#123;4, 5, 6&#125;)</span><br><span class="line">	fmt.Printf(&quot;byteSlice 3 is %v&quot;, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>上面的例子表达的是，假如直接像注释的代码那样，把B传入一个满足io.Writer的指针的方法中（含有Write方法），但是因为我们的自定义类型上面的Write是指针方法，而不是类型方法，所以会出现类型报错的问题。报错如下</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">as type io.Writer in argument to fmt.Fprintf:</span><br><span class="line">	ByteSlice does not implement io.Writer (Write method has pointer receiver)</span><br></pre></td></tr></table></div></figure>
<p>根据官方的描述，原文如下：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers.</span><br><span class="line"></span><br><span class="line">This rule arises because pointer methods can modify the receiver; invoking them on a value would cause the method to receive a copy of the value, so any modifications would be discarded. The language therefore disallows this mistake. There is a handy exception, though. When the value is addressable, the language takes care of the common case of invoking a pointer method on a value by inserting the address operator automatically. In our example, the variable b is addressable, so we can call its Write method with just b.Write. The compiler will rewrite that to (&amp;b).Write for us.</span><br></pre></td></tr></table></div></figure>
<p>翻译一下：<br>对于接收者类型是指针还是值的规则，值接收者可以 被值或者指针进行调用。而指针方法只能被指针进行调用。</p>
<p>这个规则的产生的原因是因为指针方法可以修改接受者的值。 但是以值的方式继续调用的情况下，go是会自动把值复制一份，然后继续方法的调用，所有对于里面变量得修改都会被丢弃（因为是值传递，除非使用Return +调用的地方有返回值接收）。 因此语言不允许有这种的错误出现。当值是可以获得地址的情况下，语言会自动把值获取指针传入指针调用的方法里面。 </p>

        <h1 id="Data"   >
          <a href="#Data" class="heading-link"><i class="fas fa-link"></i></a>Data</h1>
      
        <h2 id="New-vs-Make"   >
          <a href="#New-vs-Make" class="heading-link"><i class="fas fa-link"></i></a>New vs Make</h2>
      
        <h3 id="New"   >
          <a href="#New" class="heading-link"><i class="fas fa-link"></i></a>New</h3>
      <p>New 是 Go里面的分配内存的方法，但是它只会创建一个Zero值（即创建一个0的空间给对应的内存，并且返回这个变量所占有的内存地址）。</p>
<p>由于由new出来的内存占用为0。这样对于设计你自己的数据结构很有帮助，原因是因为可以默认初始化了0的值，而不用之后再去进行二次的初始化。</p>
<p>官网上的例子：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">For example, the documentation for bytes.Buffer states that &quot;the zero value for Buffer is an empty buffer ready to use.&quot; Similarly, sync.Mutex does not have an explicit constructor or Init method. Instead, the zero value for a sync.Mutex is defined to be an unlocked mutex.</span><br><span class="line"></span><br><span class="line">The zero-value-is-useful property works transitively. Consider this type declaration.</span><br><span class="line"></span><br><span class="line">type SyncedBuffer struct &#123;</span><br><span class="line">    lock    sync.Mutex</span><br><span class="line">    buffer  bytes.Buffer</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>但是有些时候直接初始化0值不要足够，需要一个构建者。像这个例子一样</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func NewFile(fd int, name string) *File &#123;</span><br><span class="line">    if fd &lt; 0 &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    f :&#x3D; new(File)</span><br><span class="line">    f.fd &#x3D; fd</span><br><span class="line">    f.name &#x3D; name</span><br><span class="line">    f.dirinfo &#x3D; nil</span><br><span class="line">    f.nepipe &#x3D; 0</span><br><span class="line">    return f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>因为上面这段代码有比较多的参数，因此我们可以用一个命名的字段来继续初始化</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func NewFile(fd int, name string) *File &#123;</span><br><span class="line">    if fd &lt; 0 &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    f :&#x3D; File&#123;fd, name, nil, 0&#125;</span><br><span class="line">    return &amp;f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>事实上，直接获取复合文字初始化的结构体的地址，实际上会创建一个全新的实例并且赋值，因此我们可以把上面的最后两行代码合成一行代码  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f :&#x3D; File&#123;fd, name, nil, 0&#125;</span><br><span class="line">    return &amp;f</span><br><span class="line">&#x3D;&#x3D;&#x3D; </span><br><span class="line"></span><br><span class="line">return &amp;File&#123;fd, name, nil, 0&#125;</span><br></pre></td></tr></table></div></figure>
<p>用于和范围： 适用于创建数组、切片、映射（with the field labels being indices or map keys as appropriate）。</p>
<p>返回值：<br>一个对应类型的指针</p>

        <h3 id="Make"   >
          <a href="#Make" class="heading-link"><i class="fas fa-link"></i></a>Make</h3>
      <p>Make 可以用于创建并且返回一个非nil的值。<br>适用范围：<br>切片、映射、channel  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make([]int,10,100)  &#x2F;&#x2F; 这样是创建了一个容量为100，但是填入了10个0的切片。</span><br></pre></td></tr></table></div></figure>
<p>官网上面对make的描述</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">For slices, maps, and channels, make initializes the internal data structure and prepares the value for use.</span><br></pre></td></tr></table></div></figure>
<p>返回值：<br>一个对应类型的数据</p>

        <h3 id="Diff"   >
          <a href="#Diff" class="heading-link"><i class="fas fa-link"></i></a>Diff</h3>
      <p>区别上面的Make和New的目的是为了，对于切片、映射、channel这三种类型，在底层的实现原理中都必须要先创建一个底层的实现才能被引用到，才能在暴露给语言的使用者上面不会抛出错误。<br>所以本质上，new创建出来的可以理解为一个nil的对象，而make创建出来的是一个带有底层数据结构，并且有非nil的对象。<br>而且返回值有所不同。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">	 &#x2F;&#x2F; allocates slice structure; *p &#x3D;&#x3D; nil; rarely useful</span><br><span class="line">	var p *[]int &#x3D; new([]int)     </span><br><span class="line">	&#x2F;&#x2F; the slice v now refers to a new array of 100 ints </span><br><span class="line">	var v []int &#x3D; make([]int, 5) </span><br><span class="line">	fmt.Printf(&quot;p values is %v，%v\n&quot;, p, *p&#x3D;&#x3D;nil)</span><br><span class="line">	fmt.Printf(&quot;v values is %v, %v\n&quot;, v, v&#x3D;&#x3D;nil)</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line">p values is &amp;[]，true</span><br><span class="line">v values is [0 0 0 0 0], false</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h2 id="Array"   >
          <a href="#Array" class="heading-link"><i class="fas fa-link"></i></a>Array</h2>
      <p>数组在Go的三个特点：</p>
<ol>
<li>如果直接把数据传入到一个函数中，则是把这个数组的值拷贝一份，然后把拷贝的副本传到函数中进行使用。</li>
<li>数组的长度也是它的类型属性之一，[10]int和[20]int不是等价的。</li>
<li>Array都是值。</li>
</ol>
<p>而且有一个使用的小技巧，如果想要减少传递的数据的量，可以直接传入指针，这样可以免于拷贝多一份中间的数据。<br>对于Go来说，因为数组类型支持的方法比较少，而且不能够通过动态去进行特定长度数组创建。因此更加建议的是用Slice来代替数组。  </p>

        <h2 id="Slice"   >
          <a href="#Slice" class="heading-link"><i class="fas fa-link"></i></a>Slice</h2>
      <p>可以看我的博客另外一篇的文章Go Slice上面有提及高级的用法，此处不再重复。  </p>

        <h3 id="二维数组和二维切片"   >
          <a href="#二维数组和二维切片" class="heading-link"><i class="fas fa-link"></i></a>二维数组和二维切片</h3>
      <p>对于二维数组的声明，可以使用这样的方法  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Transform [3][3]float64  &#x2F;&#x2F; A 3x3 array, really an array of arrays.</span><br><span class="line">type LinesOfText [][]byte     &#x2F;&#x2F; A slice of byte slices.</span><br><span class="line"></span><br><span class="line">text :&#x3D; LinesOfText&#123;</span><br><span class="line">	[]byte(&quot;Now is the time&quot;),</span><br><span class="line">	[]byte(&quot;for all good gophers&quot;),</span><br><span class="line">	[]byte(&quot;to bring some fun to the party.&quot;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如果使用Make来继续初始化的情况。需要考虑两个不同的使用场景导致的初始化方式的不同。<br>第一种：如果内部的一位数组可能发生扩展或者收缩，那么就要单独去分配这个一位数组。<br>第二种： 如果内部的数组长度不会发生size变化而只会发生值得变化，则可以进行统一得初始化。(这样性能会比较好，因为可以一次性的调用Allocate的系统函数，减少分配内存的开销)</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; First Method</span><br><span class="line">picture :&#x3D; make([][]uint8, YSize)</span><br><span class="line">for i:&#x3D; range picture&#123;</span><br><span class="line">    picture[i] &#x3D; make([]uint8, XSize)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Second Method </span><br><span class="line">picture :&#x3D; make([][]uint8, YSize)</span><br><span class="line">pixels :&#x3D; make([]uint8, XSize * YSize)</span><br><span class="line"></span><br><span class="line">for i :&#x3D; range picture&#123;</span><br><span class="line">    picture[i], pixels &#x3D; pixels[:XSize], pixels[XSize:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h2 id="Map"   >
          <a href="#Map" class="heading-link"><i class="fas fa-link"></i></a>Map</h2>
      <p>主要注意当一个Key不存在与一个Map中的情况下，需要使用这种方法来进行判断</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var tz map[string]int</span><br><span class="line">var ds string &#x3D; &quot;abc&quot;</span><br><span class="line">if val, ok :&#x3D; tz[ds]; ok&#123;</span><br><span class="line">    return val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>同理在上面的例子上面，如果反过来进行使用，可以用于判断Key是否存在于Map中。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var tz map[string]int</span><br><span class="line">var ds string &#x3D; &quot;abc&quot;</span><br><span class="line">_, exist :&#x3D; tz[ds]</span><br><span class="line">if !exist &#123;</span><br><span class="line">    return &quot;is not exist&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如果需要删除一个值的情况下,使用delete的函数进行处理</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var tz map[string]int</span><br><span class="line">var ds string &#x3D; &quot;abc&quot;</span><br><span class="line">&#x2F;&#x2F; delete(map, key)</span><br><span class="line">delete(tz, ds)</span><br></pre></td></tr></table></div></figure>

        <h2 id="Append"   >
          <a href="#Append" class="heading-link"><i class="fas fa-link"></i></a>Append</h2>
      <p>Append 可以接受多个参数</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func append(slice []T, elements ...T) []T</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; use case </span><br><span class="line">x :&#x3D; []int&#123;1,2,3&#125;</span><br><span class="line">x &#x3D; append(x, 4, 5, 6)</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></div></figure>
<p>对于如果要把两个数组直接接起来的情况下</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x :&#x3D; []int&#123;1,2,3&#125;</span><br><span class="line">y :&#x3D; []int&#123;4,5,6&#125;</span><br><span class="line">x &#x3D; append(x, y...)</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></div></figure>

        <h1 id="InterFace"   >
          <a href="#InterFace" class="heading-link"><i class="fas fa-link"></i></a>InterFace</h1>
      
        <h2 id="Interface"   >
          <a href="#Interface" class="heading-link"><i class="fas fa-link"></i></a>Interface</h2>
      <p>一个结构体可以实现多个接口，只要它实现了那些接口所定义的方法。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">type Sequence []int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Methods required by sort.Interface.</span><br><span class="line">func (s Sequence) Len() int &#123;</span><br><span class="line">    return len(s)</span><br><span class="line">&#125;</span><br><span class="line">func (s Sequence) Less(i, j int) bool &#123;</span><br><span class="line">    return s[i] &lt; s[j]</span><br><span class="line">&#125;</span><br><span class="line">func (s Sequence) Swap(i, j int) &#123;</span><br><span class="line">    s[i], s[j] &#x3D; s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Copy returns a copy of the Sequence.</span><br><span class="line">func (s Sequence) Copy() Sequence &#123;</span><br><span class="line">    copy :&#x3D; make(Sequence, 0, len(s))</span><br><span class="line">    return append(copy, s...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Method for printing - sorts the elements before printing.</span><br><span class="line">func (s Sequence) String() string &#123;</span><br><span class="line">    s &#x3D; s.Copy() &#x2F;&#x2F; Make a copy; don&#39;t overwrite argument.</span><br><span class="line">    sort.Sort(s)</span><br><span class="line">    str :&#x3D; &quot;[&quot;</span><br><span class="line">    for i, elem :&#x3D; range s &#123; &#x2F;&#x2F; Loop is O(N²); will fix that in next example.</span><br><span class="line">        if i &gt; 0 &#123;</span><br><span class="line">            str +&#x3D; &quot; &quot;</span><br><span class="line">        &#125;</span><br><span class="line">        str +&#x3D; fmt.Sprint(elem)</span><br><span class="line">    &#125;</span><br><span class="line">    return str + &quot;]&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="Coversions"   >
          <a href="#Coversions" class="heading-link"><i class="fas fa-link"></i></a>Coversions</h2>
      <p>上面所引用的到方法其实是重新实现了fmt包里面的Sprint方法。我们可以用一些方法来为这个提速，在调用Sprint之前把数据转换成[]int类型，因为Sequence的本质上就<br>是[]int。  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改前</span><br><span class="line">func (s Sequence) String() string &#123;</span><br><span class="line">    s &#x3D; s.Copy()</span><br><span class="line">    sort.Sort(s)</span><br><span class="line">    return fmt.Sprint([]int(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改后</span><br><span class="line">type Sequence []int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Method for printing - sorts the elements before printing</span><br><span class="line">func (s Sequence) String() string &#123;</span><br><span class="line">    s &#x3D; s.Copy()</span><br><span class="line">    sort.IntSlice(s).Sort()</span><br><span class="line">    return fmt.Sprint([]int(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="type-assertions"   >
          <a href="#type-assertions" class="heading-link"><i class="fas fa-link"></i></a>type assertions</h2>
      <p>使用Type switch 实际上的操作会把那个变量根据分支的判断的类型来转型。<br>下面这段代码是一个例子，目的是如果不是string类型, 调用其String()进行输出。而如果是，直接输出。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Stringer interface &#123;</span><br><span class="line">    String() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var value interface&#123;&#125; &#x2F;&#x2F; Value provided by caller.</span><br><span class="line">switch str :&#x3D; value.(type) &#123;</span><br><span class="line">case string:</span><br><span class="line">    return str</span><br><span class="line">case Stringer:</span><br><span class="line">    return str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如果对于使用场景是单分支，只需要判断接口是否为那个类型的实现的情况下，可以使用</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; </span><br><span class="line">str, ok :&#x3D; value.(string)</span><br></pre></td></tr></table></div></figure>
<p>注意的是继续类型推断的情况下，必须要填入实际的类型，不能再填入Interface。</p>

        <h2 id="Generality"   >
          <a href="#Generality" class="heading-link"><i class="fas fa-link"></i></a>Generality</h2>
      <p>如果包里面的一个类型只是为了实现接口并且其他方法不需要进行导出给外部使用的情况下。只需要导出接口就好，这样可以避免对于使用者不感兴趣的方法的实现的复杂度。<br>如官方的Hash模块，crc32.NewIEEE 和 adler32.New这两个方法都是返回 接口类型Hash.Hash32。</p>

        <h2 id="interface-amp-method"   >
          <a href="#interface-amp-method" class="heading-link"><i class="fas fa-link"></i></a>interface &amp; method</h2>
      <p>只要这个类型实现了这个接口的所有方法，即可以把这个类型传入来当接口使用.可以理解为简单的依赖翻转。</p>

        <h1 id="Error"   >
          <a href="#Error" class="heading-link"><i class="fas fa-link"></i></a>Error</h1>
      
        <h2 id="Defination"   >
          <a href="#Defination" class="heading-link"><i class="fas fa-link"></i></a>Defination</h2>
      <p>Error 接口在代码里面的定义是这样的。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">    Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如果需要实现一个自定义的Error（添加部分与业务相关的信息）</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; PathError records an error and the operation and</span><br><span class="line">&#x2F;&#x2F; file path that caused it.</span><br><span class="line">type PathError struct &#123;</span><br><span class="line">    Op string    &#x2F;&#x2F; &quot;open&quot;, &quot;unlink&quot;, etc.</span><br><span class="line">    Path string  &#x2F;&#x2F; The associated file.</span><br><span class="line">    Err error    &#x2F;&#x2F; Returned by the system call.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *PathError) Error() string &#123;</span><br><span class="line">    return e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>并且建议的可行方法，错误信息应该能够表明他们的来源（即发生错误的模块是哪个模块的哪个函数）。<br>一般来说，函数调用者如果关心具体的错误信息的话，可以使用一个类型switch来获取具体的错误类型和相信信息。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for try :&#x3D; 0; try &lt; 2; try++ &#123;</span><br><span class="line">    file, err &#x3D; os.Create(filename)</span><br><span class="line">    if err &#x3D;&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    if e, ok :&#x3D; err.(*os.PathError); ok &amp;&amp; e.Err &#x3D;&#x3D; syscall.ENOSPC &#123;</span><br><span class="line">        deleteTempFiles()  &#x2F;&#x2F; Recover some space.</span><br><span class="line">        continue</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="Panic"   >
          <a href="#Panic" class="heading-link"><i class="fas fa-link"></i></a>Panic</h2>
      <p>对于预设以内的错误，返回错误的方式应该是返回错误的信息为多一个参数.</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func Get() (string, Error)&#123;</span><br><span class="line">    return &quot;&quot;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k, err :&#x3D; Get()</span><br></pre></td></tr></table></div></figure>
<p>但是对于不可恢复的错误，我们不能让程序继续运行。<br>Panic()的作用是创建一个Runtime Error并且使得程序无法继续运行。<br>Panic可以接受任意长度的参数，并且打印到日志上，</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func CubeRoot(x float64) float64 &#123;</span><br><span class="line">    z :&#x3D; x&#x2F;3   &#x2F;&#x2F; Arbitrary initial value</span><br><span class="line">    for i :&#x3D; 0; i &lt; 1e6; i++ &#123;</span><br><span class="line">        prevz :&#x3D; z</span><br><span class="line">        z -&#x3D; (z*z*z-x) &#x2F; (3*z*z)</span><br><span class="line">        if veryClose(z, prevz) &#123;</span><br><span class="line">            return z</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; A million iterations has not converged; something is wrong.</span><br><span class="line">    panic(fmt.Sprintf(&quot;CubeRoot(%g) did not converge&quot;, x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>官方对于Panic的态度：程序员应该尽可能的去考虑并且解决所有的异常的情况。<br>对于真实的代码库上面不建议使用这个方法。</p>

        <h2 id="Recover"   >
          <a href="#Recover" class="heading-link"><i class="fas fa-link"></i></a>Recover</h2>
      <p>用于恢复发生Panic的Goroutine。但是必须在panic前面的地方添加一个defer 并且把Recover函数放入其中。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func server(workChan &lt;-chan *Work) &#123;</span><br><span class="line">    for work :&#x3D; range workChan &#123;</span><br><span class="line">        go safelyDo(work)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func safelyDo(work *Work) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        if err :&#x3D; recover(); err !&#x3D; nil &#123;</span><br><span class="line">            log.Println(&quot;work failed:&quot;, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    do(work)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>官方库中处理复杂错误的例子，Regexp</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Error is the type of a parse error; it satisfies the error interface.</span><br><span class="line">type Error string</span><br><span class="line">func (e Error) Error() string &#123;</span><br><span class="line">    return string(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; error is a method of *Regexp that reports parsing errors by</span><br><span class="line">&#x2F;&#x2F; panicking with an Error.</span><br><span class="line">func (regexp *Regexp) error(err string) &#123;</span><br><span class="line">    panic(Error(err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Compile returns a parsed representation of the regular expression.</span><br><span class="line">func Compile(str string) (regexp *Regexp, err error) &#123;</span><br><span class="line">    regexp &#x3D; new(Regexp)</span><br><span class="line">    &#x2F;&#x2F; doParse will panic if there is a parse error.</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        if e :&#x3D; recover(); e !&#x3D; nil &#123;</span><br><span class="line">            regexp &#x3D; nil    &#x2F;&#x2F; Clear return value.</span><br><span class="line">            err &#x3D; e.(Error) &#x2F;&#x2F; Will re-panic if not a parse error.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return regexp.doParse(str), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>即使上面把regexp 的类型变成了nil。但是如果在e判断类型的时候如果不是Error的类型。程序仍然会发生错误，并且崩溃推出。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if pos &#x3D;&#x3D; 0 &#123;</span><br><span class="line">    re.error(&quot;&#39;*&#39; illegal at start of expression&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>对于上面的这种re-panic的策略，官方建议是在一个包内进行使用，这样就不会把错误暴露给Client。<br>虽然re-panic最终程序还是崩溃了，但是这样可以使得程序具体的错误可以过滤一层，并且找到更加直接的错误的原因。</p>

        <h1 id="PackageInit"   >
          <a href="#PackageInit" class="heading-link"><i class="fas fa-link"></i></a>PackageInit</h1>
      <p>可以直接看<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34211611" >译文</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>即可。</p>
<p>也可以直接读介绍的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://medium.com/golangspec/init-functions-in-go-eac191b3860a" >原文</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="Defer"   >
          <a href="#Defer" class="heading-link"><i class="fas fa-link"></i></a>Defer</h1>
      <p>Defer语法是在函数返回前进行调度的清除函数调用。它能够很好地处理多分支返回情况下的释放资源的问题。（类似于Python的With语法）</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func Contents(filename string) (string, error) &#123;</span><br><span class="line">    f, err :&#x3D; os.Open(filename)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return &quot;&quot;, err</span><br><span class="line">    &#125;</span><br><span class="line">    defer f.Close()  &#x2F;&#x2F; f.Close will run when we&#39;re finished.</span><br><span class="line"></span><br><span class="line">    var result []byte</span><br><span class="line">    buf :&#x3D; make([]byte, 100)</span><br><span class="line">    for &#123;</span><br><span class="line">        n, err :&#x3D; f.Read(buf[0:])</span><br><span class="line">        result &#x3D; append(result, buf[0:n]...) &#x2F;&#x2F; append is discussed later.</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            return &quot;&quot;, err  &#x2F;&#x2F; f will be closed if we return here.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return string(result), nil &#x2F;&#x2F; f will be closed if we return here.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">官方对于Defer的好处声明：</span><br><span class="line">1. 位置更加接近，更好的可以清晰的看出操作</span><br><span class="line">2. 防止资源忘了关闭导致的泄露问题</span><br></pre></td></tr></table></div></figure>
<p>延迟函数（如果函数是方法，则包括接收方）的参数在延迟执行时而不是在调用执行时进行评估。除了避免担心函数执行时变量会更改值外，这还意味着单个延迟的调用站点可以延迟多个函数的执行。这是一个简单的例子。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	for i :&#x3D; 0; i &lt; 5; i++ &#123;</span><br><span class="line">    		defer fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line">output:</span><br><span class="line">4 3 2 1 0 </span><br></pre></td></tr></table></div></figure>
<p>Defer函数的执行吮吸是LIFO（LastInFirstOut)栈的结构。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func trace(s string) string &#123;</span><br><span class="line">    fmt.Println(&quot;entering:&quot;, s)</span><br><span class="line">    return s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func un(s string) &#123;</span><br><span class="line">    fmt.Println(&quot;leaving:&quot;, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func a() &#123;</span><br><span class="line">    defer un(trace(&quot;a&quot;))</span><br><span class="line">    fmt.Println(&quot;in a&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func b() &#123;</span><br><span class="line">    defer un(trace(&quot;b&quot;))</span><br><span class="line">    fmt.Println(&quot;in b&quot;)</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br><span class="line">-------------------</span><br><span class="line">output</span><br><span class="line">entering: b</span><br><span class="line">in b</span><br><span class="line">entering: a</span><br><span class="line">in a</span><br><span class="line">leaving: a</span><br><span class="line">leaving: b</span><br></pre></td></tr></table></div></figure>
<p>从上面的例子可以看出来，defer函数只能包含一层，如果像上面的代码 defer un(trace()), 那么会先执行trace()，然后再把un()函数压入defer的栈中。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/_wZQID0VatIlAiH6-x3U6A" >更加实际的使用场景相关的例子</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="ShareNote"   >
          <a href="#ShareNote" class="heading-link"><i class="fas fa-link"></i></a>ShareNote</h1>
      <ol>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://golang.org/doc/effective_go.html" >EffectiveGo</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://medium.com/golangspec/init-functions-in-go-eac191b3860a" >GoInitFunc</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34211611" >GoInitFunc译文</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/09/10/sql-revise/">SQL复习</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-01-22</span></span></div></header><div class="post-body"><div class="post-excerpt"><!-- ---
layout: post
title: SQL复习
author: Ray Chan(ray1888)
date: '2019-09-10 10:05:38 +0800'
category: sql
summary: sql-revise for interview 
thumbnail: sql.jfif
--- -->


        <h1 id="目录"   >
          <a href="#目录" class="heading-link"><i class="fas fa-link"></i></a>目录</h1>
      <ol>
<li><a href="#Join">Join</a><br> 1.1 <a href="#BasicJoin">基本Join类型</a><br> 1.2 <a href="#AdvanceJoin">高级Join类型</a></li>
<li><a href="#ViewNSubquery">视图和子查询</a><br> 2.1 <a href="#View">视图</a><br> 2.2 <a href="#Subquery">子查询</a>  </li>
<li><a href="#Gramma">基本语法</a><br> 3.1 <a href="#Select">Select</a><br> 3.2 <a href="#OrderBy">OrderBy</a><br> 3.3 <a href="#Update">Update</a><br> 3.4 <a href="#Delete">Delete</a>  </li>
<li><a href="#HavingNGroupBy">Having &amp; GroupBy</a>  </li>
<li><a href="#Notice">注意事项</a>  </li>
<li><a href="#ShareNote">ShareNote</a>  </li>
</ol>

        <h1 id="目的"   >
          <a href="#目的" class="heading-link"><i class="fas fa-link"></i></a>目的</h1>
      <p>因为之前工作上面一直使用Python的ORM，然后很少使用手写SQL，因此需要回顾一些Sql的用法。</p>

        <h1 id="Join"   >
          <a href="#Join" class="heading-link"><i class="fas fa-link"></i></a>Join</h1>
      
        <h2 id="此处所提及的表的数据和表类型"   >
          <a href="#此处所提及的表的数据和表类型" class="heading-link"><i class="fas fa-link"></i></a>此处所提及的表的数据和表类型</h2>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">TABLE_A</span><br><span class="line">  PK Value</span><br><span class="line">---- ----------</span><br><span class="line">   1 FOX</span><br><span class="line">   2 COP</span><br><span class="line">   3 TAXI</span><br><span class="line">   6 WASHINGTON</span><br><span class="line">   7 DELL</span><br><span class="line">   5 ARIZONA</span><br><span class="line">   4 LINCOLN</span><br><span class="line">  10 LUCENT</span><br><span class="line"></span><br><span class="line">TABLE_B</span><br><span class="line">  PK Value</span><br><span class="line">---- ----------</span><br><span class="line">   1 TROT</span><br><span class="line">   2 CAR</span><br><span class="line">   3 CAB</span><br><span class="line">   6 MONUMENT</span><br><span class="line">   7 PC</span><br><span class="line">   8 MICROSOFT</span><br><span class="line">   9 APPLE</span><br><span class="line">  11 SCOTCH</span><br></pre></td></tr></table></div></figure>

        <h2 id="基本Join类型"   >
          <a href="#基本Join类型" class="heading-link"><i class="fas fa-link"></i></a>基本Join类型</h2>
      
        <h3 id="InnerJoin"   >
          <a href="#InnerJoin" class="heading-link"><i class="fas fa-link"></i></a>InnerJoin</h3>
      <!-- ![InnerJoin](/assets/img/posts/sqlJoin/INNER_JOIN.png) -->
<img src="/2019/09/10/sql-revise/INNER_JOIN.png" class="" title="InnerJoin">

<p>求表A与表B数据的交集部分    </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- INNER JOIN</span><br><span class="line">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class="line">       B.Value AS B_Value, B.PK AS B_PK</span><br><span class="line">FROM Table_A A</span><br><span class="line">INNER JOIN Table_B B</span><br><span class="line">ON A.PK &#x3D; B.PK</span><br><span class="line"></span><br><span class="line">A_PK A_Value    B_Value    B_PK</span><br><span class="line">---- ---------- ---------- ----</span><br><span class="line">   1 FOX        TROT          1</span><br><span class="line">   2 COP        CAR           2</span><br><span class="line">   3 TAXI       CAB           3</span><br><span class="line">   6 WASHINGTON MONUMENT      6</span><br><span class="line">   7 DELL       PC            7</span><br><span class="line"></span><br><span class="line">(5 row(s) affected)</span><br></pre></td></tr></table></div></figure>

        <h3 id="LeftJoin"   >
          <a href="#LeftJoin" class="heading-link"><i class="fas fa-link"></i></a>LeftJoin</h3>
      <!-- ![InnerJoin](/assets/img/posts/sqlJoin/LEFT_JOIN.png) -->
<img src="/2019/09/10/sql-revise/LEFT_JOIN.png" class="" title="LeftJoin">

<p>选取表A的所有数据, 在此例子中，如果表B不存在对应查询的ID的时候，则会填入Null  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- LEFT JOIN</span><br><span class="line">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class="line">B.Value AS B_Value, B.PK AS B_PK</span><br><span class="line">FROM Table_A A</span><br><span class="line">LEFT JOIN Table_B B</span><br><span class="line">ON A.PK &#x3D; B.PK</span><br><span class="line"></span><br><span class="line">A_PK A_Value    B_Value    B_PK</span><br><span class="line">---- ---------- ---------- ----</span><br><span class="line">   1 FOX        TROT          1</span><br><span class="line">   2 COP        CAR           2</span><br><span class="line">   3 TAXI       CAB           3</span><br><span class="line">   4 LINCOLN    NULL       NULL</span><br><span class="line">   5 ARIZONA    NULL       NULL</span><br><span class="line">   6 WASHINGTON MONUMENT      6</span><br><span class="line">   7 DELL       PC            7</span><br><span class="line">  10 LUCENT     NULL       NULL</span><br><span class="line"></span><br><span class="line">(8 row(s) affected)</span><br></pre></td></tr></table></div></figure>

        <h3 id="RightJoin"   >
          <a href="#RightJoin" class="heading-link"><i class="fas fa-link"></i></a>RightJoin</h3>
      <!-- ![InnerJoin](/assets/img/posts/sqlJoin/RIGHT_JOIN.png) -->
<img src="/2019/09/10/sql-revise/RIGHT_JOIN.png" class="" title="RightJoin">

<p>选取表B的所有数据，在此例子中，如果表A不存在对应查询的ID的时候，则会填入Null  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- RIGHT JOIN</span><br><span class="line">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class="line">B.Value AS B_Value, B.PK AS B_PK</span><br><span class="line">FROM Table_A A</span><br><span class="line">RIGHT JOIN Table_B B</span><br><span class="line">ON A.PK &#x3D; B.PK</span><br><span class="line"></span><br><span class="line">A_PK A_Value    B_Value    B_PK</span><br><span class="line">---- ---------- ---------- ----</span><br><span class="line">   1 FOX        TROT          1</span><br><span class="line">   2 COP        CAR           2</span><br><span class="line">   3 TAXI       CAB           3</span><br><span class="line">   6 WASHINGTON MONUMENT      6</span><br><span class="line">   7 DELL       PC            7</span><br><span class="line">NULL NULL       MICROSOFT     8</span><br><span class="line">NULL NULL       APPLE         9</span><br><span class="line">NULL NULL       SCOTCH       11</span><br><span class="line"></span><br><span class="line">(8 row(s) affected)</span><br></pre></td></tr></table></div></figure>

        <h3 id="OuterJoin"   >
          <a href="#OuterJoin" class="heading-link"><i class="fas fa-link"></i></a>OuterJoin</h3>
      <!-- ![InnerJoin](/assets/img/posts/sqlJoin/FULL_OUTER_JOIN.png) -->
<img src="/2019/09/10/sql-revise/FULL_OUTER_JOIN.png" class="" title="FullOuterJoin">

<p>选取表A与表B的数据的全集,当另一张表缺失的情况下，会填补NUll信息  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-- OUTER JOIN</span><br><span class="line">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class="line">B.Value AS B_Value, B.PK AS B_PK</span><br><span class="line">FROM Table_A A</span><br><span class="line">FULL OUTER JOIN Table_B B</span><br><span class="line">ON A.PK &#x3D; B.PK</span><br><span class="line"></span><br><span class="line">A_PK A_Value    B_Value    B_PK</span><br><span class="line">---- ---------- ---------- ----</span><br><span class="line">   1 FOX        TROT          1</span><br><span class="line">   2 COP        CAR           2</span><br><span class="line">   3 TAXI       CAB           3</span><br><span class="line">   6 WASHINGTON MONUMENT      6</span><br><span class="line">   7 DELL       PC            7</span><br><span class="line">NULL NULL       MICROSOFT     8</span><br><span class="line">NULL NULL       APPLE         9</span><br><span class="line">NULL NULL       SCOTCH       11</span><br><span class="line">   5 ARIZONA    NULL       NULL</span><br><span class="line">   4 LINCOLN    NULL       NULL</span><br><span class="line">  10 LUCENT     NULL       NULL</span><br><span class="line"></span><br><span class="line">(11 row(s) affected)</span><br></pre></td></tr></table></div></figure>

        <h2 id="高级Join类型"   >
          <a href="#高级Join类型" class="heading-link"><i class="fas fa-link"></i></a>高级Join类型</h2>
      
        <h3 id="LEFT-JOIN-EXCLUDING-INNER-JOIN"   >
          <a href="#LEFT-JOIN-EXCLUDING-INNER-JOIN" class="heading-link"><i class="fas fa-link"></i></a>LEFT JOIN EXCLUDING INNER JOIN</h3>
      <!-- ![LeftJoin](/assets/img/posts/sqlJoin/LEFT_EXCLUDING_JOIN.png) -->
<img src="/2019/09/10/sql-revise/LEFT_EXCLUDING_JOIN.png" class="" title="LeftExcludeJoin">

<p>选择A与B中，A没有与B有交集的部分  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- LEFT EXCLUDING JOIN</span><br><span class="line">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class="line">B.Value AS B_Value, B.PK AS B_PK</span><br><span class="line">FROM Table_A A</span><br><span class="line">LEFT JOIN Table_B B</span><br><span class="line">ON A.PK &#x3D; B.PK</span><br><span class="line">WHERE B.PK IS NULL</span><br><span class="line"></span><br><span class="line">A_PK A_Value    B_Value    B_PK</span><br><span class="line">---- ---------- ---------- ----</span><br><span class="line">   4 LINCOLN    NULL       NULL</span><br><span class="line">   5 ARIZONA    NULL       NULL</span><br><span class="line">  10 LUCENT     NULL       NULL</span><br><span class="line">(3 row(s) affected)</span><br></pre></td></tr></table></div></figure>

        <h3 id="RIGHT-JOIN-EXCLUDING-INNER-JOIN"   >
          <a href="#RIGHT-JOIN-EXCLUDING-INNER-JOIN" class="heading-link"><i class="fas fa-link"></i></a>RIGHT JOIN EXCLUDING INNER JOIN</h3>
      <!-- ![InnerJoin](/assets/img/posts/sqlJoin/RIGHT_EXCLUDING_JOIN.png) -->
<img src="/2019/09/10/sql-revise/RIGHT_EXCLUDING_JOIN.png" class="" title="RightExcludeJoin">


<p>选择A与B中，B没有与A有交集的部分  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- RIGHT EXCLUDING JOIN</span><br><span class="line">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class="line">B.Value AS B_Value, B.PK AS B_PK</span><br><span class="line">FROM Table_A A</span><br><span class="line">RIGHT JOIN Table_B B</span><br><span class="line">ON A.PK &#x3D; B.PK</span><br><span class="line">WHERE A.PK IS NULL</span><br><span class="line"></span><br><span class="line">A_PK A_Value    B_Value    B_PK</span><br><span class="line">---- ---------- ---------- ----</span><br><span class="line">NULL NULL       MICROSOFT     8</span><br><span class="line">NULL NULL       APPLE         9</span><br><span class="line">NULL NULL       SCOTCH       11</span><br><span class="line"></span><br><span class="line">(3 row(s) affected)</span><br></pre></td></tr></table></div></figure>

        <h3 id="OUTER-JOIN-EXCLUDING-INNER-JOIN"   >
          <a href="#OUTER-JOIN-EXCLUDING-INNER-JOIN" class="heading-link"><i class="fas fa-link"></i></a>OUTER JOIN EXCLUDING INNER JOIN</h3>
      <!-- ![InnerJoin](/assets/img/posts/sqlJoin/OUTER_EXCLUDING_JOIN.png) -->
<img src="/2019/09/10/sql-revise/OUTER_EXCLUDING_JOIN.png" class="" title="InnerJoin">

<p>选择A与B中，A没有与B有交集的部分和B与A没有交集的部分  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- OUTER EXCLUDING JOIN</span><br><span class="line">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class="line">B.Value AS B_Value, B.PK AS B_PK</span><br><span class="line">FROM Table_A A</span><br><span class="line">FULL OUTER JOIN Table_B B</span><br><span class="line">ON A.PK &#x3D; B.PK</span><br><span class="line">WHERE A.PK IS NULL</span><br><span class="line">OR B.PK IS NULL</span><br><span class="line"></span><br><span class="line">A_PK A_Value    B_Value    B_PK</span><br><span class="line">---- ---------- ---------- ----</span><br><span class="line">NULL NULL       MICROSOFT     8</span><br><span class="line">NULL NULL       APPLE         9</span><br><span class="line">NULL NULL       SCOTCH       11</span><br><span class="line">   5 ARIZONA    NULL       NULL</span><br><span class="line">   4 LINCOLN    NULL       NULL</span><br><span class="line">  10 LUCENT     NULL       NULL</span><br><span class="line"></span><br><span class="line">(6 row(s) affected)</span><br></pre></td></tr></table></div></figure>


        <h1 id="视图与子查询"   >
          <a href="#视图与子查询" class="heading-link"><i class="fas fa-link"></i></a>视图与子查询</h1>
      
        <h2 id="视图"   >
          <a href="#视图" class="heading-link"><i class="fas fa-link"></i></a>视图</h2>
      <p>视图并不是用来保存数据的，而是通过保存读取数据的SELECT 语句的方法来为用户提供便利的工具。  </p>
<p>究竟视图是什么呢？如果用一句话概述的话，就是“从SQL 的角度来看视图就是一张表”。实际上，在SQL 语句中并不需要区分哪些是表，哪些是视图。<br>视图和表的差别：区别只有一个，那就是“是否保存了实际的数据”。<br>但是使用视图时并不会将数据保存到存储设备之中，而且也不会将数据保存到其他任何地方。实际上视图保存的是SELECT 语句（图5-1）。我们从视图中读取数据时，视图会在内部执行该SELECT 语句并创建出一张临时表。</p>
<p>视图是需要通过create view 的语法来创建的，本质也是满足一定条件的数据的集合。</p>

        <h3 id="限制"   >
          <a href="#限制" class="heading-link"><i class="fas fa-link"></i></a>限制</h3>
      <ol>
<li>视图不可以与Group By 同时使用（可能某些DB会不支持）</li>
</ol>

        <h2 id="子查询"   >
          <a href="#子查询" class="heading-link"><i class="fas fa-link"></i></a>子查询</h2>
      <p>基础定义：子查询就是一次性的视图（SELECT语句）。与视图不同，子查询在SELECT语句执行完毕之后就会消失。  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select col_1 from (select col2_ from j  where $cond 1) p where $cond2</span><br><span class="line"></span><br><span class="line">其中</span><br><span class="line">p为子查询，内容为select col2_ from j  where $cond 1 满足这个条件的 j 表数据创建出来的新临时表</span><br></pre></td></tr></table></div></figure>

        <h3 id="标量子查询"   >
          <a href="#标量子查询" class="heading-link"><i class="fas fa-link"></i></a>标量子查询</h3>
      <p>而标量子查询则有一个特殊的限制，那就是必须而且只能返回1 行1列的结果。也就是返回表中某一行的某一列的值。<br>由于返回的是单一的值，因此标量子查询的返回值可以用在= 或者&lt;&gt; 这样需要单一值的比较运算符之中。  </p>

        <h4 id="标量子查询的书写位置"   >
          <a href="#标量子查询的书写位置" class="heading-link"><i class="fas fa-link"></i></a>标量子查询的书写位置</h4>
      <p>可以再任意位置： SELECT 子句、GROUP BY 子句、HAVING 子句，还是ORDERBY 子句，几乎所有的地方都可以使用。  </p>

        <h1 id="基本语法"   >
          <a href="#基本语法" class="heading-link"><i class="fas fa-link"></i></a>基本语法</h1>
      
        <h2 id="select"   >
          <a href="#select" class="heading-link"><i class="fas fa-link"></i></a>select</h2>
      <p>基础的选择操作</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select col1, col2, col..... from table1... where $cond</span><br></pre></td></tr></table></div></figure>

        <h3 id="Select-中-引用别名列"   >
          <a href="#Select-中-引用别名列" class="heading-link"><i class="fas fa-link"></i></a>Select 中 引用别名列</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from (select sal as salary, comm as commission from emp) x where salary &lt; 5000</span><br></pre></td></tr></table></div></figure>
<p>上面的这种方法可以处理类似的情况：  </p>
<ol>
<li>聚合函数(Sum()、Min()、Max())</li>
<li>标量子查询</li>
<li>窗口函数</li>
<li>别名</li>
</ol>
<p>将含有别名列的查询放入内嵌视图，就可以在外层查询中引用别名列。为什么要这么做<br>呢？ WHERE 子句会比SELECT 子句先执行，就最初那个失败的查询例子而言，当WHERE 子句<br>被执行时，SALARY 和COMMISSION 尚不存在。直到WHERE 子句执行完毕，那些别名列才会生<br>效。然而，FROM 子句会先于WHERE 子句执行。如果把最初的那个查询放入一个FROM 子句，<br>其查询结果会在最外层的WHERE 子句开始之前产生，这样一来，最外层的WHERE 子句就能<br>“看见”别名列了。当表里的某些列没有被恰当命名的时候，这个技巧尤其有用。  </p>

        <h3 id="使用条件逻辑"   >
          <a href="#使用条件逻辑" class="heading-link"><i class="fas fa-link"></i></a>使用条件逻辑</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select col1 , col2 ,</span><br><span class="line">       case when col2 &lt;&#x3D; 2000 then &quot;UnderPAID&quot;</span><br><span class="line">            when col2 &gt; 4000 then &quot;OVERPAID&quot;</span><br><span class="line">        end as status</span><br><span class="line">    from emp </span><br></pre></td></tr></table></div></figure>
<p>输出的列为[col1, status]  </p>

        <h3 id="限制返回条数"   >
          <a href="#限制返回条数" class="heading-link"><i class="fas fa-link"></i></a>限制返回条数</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp limit 1</span><br></pre></td></tr></table></div></figure>
<p>随机返回固定条数</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp order by rand() limit 5 </span><br></pre></td></tr></table></div></figure>

        <h3 id="Null的判断"   >
          <a href="#Null的判断" class="heading-link"><i class="fas fa-link"></i></a>Null的判断</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  判断col1 是否为空</span><br><span class="line">select * from emp where col1 is null</span><br><span class="line">&#x2F;&#x2F;  判断col2 是否不为空</span><br><span class="line">select * from emp where col2 is not null</span><br></pre></td></tr></table></div></figure>

        <h3 id="Union"   >
          <a href="#Union" class="heading-link"><i class="fas fa-link"></i></a>Union</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select deptno from emp </span><br><span class="line">union </span><br><span class="line">select deptno from dept </span><br></pre></td></tr></table></div></figure>

<p>如果Union想获取到重复的条目，则应该使用union all   </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果使用union all 的等价实现</span><br><span class="line">select distinct deptno from</span><br><span class="line">(select deptno from emp </span><br><span class="line">union all </span><br><span class="line">select deptno from dept )</span><br></pre></td></tr></table></div></figure>

        <h3 id="对于多表Join查询"   >
          <a href="#对于多表Join查询" class="heading-link"><i class="fas fa-link"></i></a>对于多表Join查询</h3>
      
        <h4 id="合并相关的行"   >
          <a href="#合并相关的行" class="heading-link"><i class="fas fa-link"></i></a>合并相关的行</h4>
      <p>目的：对一个共同的列或者具有相同值的列做连接查询，返回多个表中的行。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select e.name, d.loc from emp e , dept d </span><br><span class="line">where e.deptno &#x3D; 10 and e.deptno &#x3D; d.deptno</span><br></pre></td></tr></table></div></figure>
<p>这个解决方案是一个关于连接查询的例子。更准确地说，它是内连接中的相等连接。连接<br>查询是一种把来自两个表的行合并起来的操作。对于相等连接而言，其连接条件依赖于某<br>个相等条件（例如，一个表的部门编号和另一个表的部门编号相等）。内连接是最早的一<br>种连接，它返回的每一行都包含了来自参与连接查询的各个表的数据。</p>
<p>理论上，连接操作首先会依据FROM 子句里列出的表生成笛卡儿积（列出所有可能的行组<br>合），如下所示。</p>
<!-- ![Union1](/assets/img/posts/sqlPost/Union-1.png) -->
<img src="/2019/09/10/sql-revise/Union-1.png" class="" title="Union1">
<p>EMP 表里部门编号为10 的全部员工与DEPT 表的所有部门组合都被列出来了。然后，通过<br>WHERE 子句里的e.deptno 和d.deptno 做连接操作，限定了只有EMP.DEPTNO 和DEPT.DEPTNO<br>相等的行才会被返回。</p>
<!-- ![Union2](/assets/img/posts/sqlPost/Union-2.png) -->
<img src="/2019/09/10/sql-revise/Union-2.png" class="" title="Union2">

<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类似实现，使用显式的Join来实现</span><br><span class="line">select e.name, d.loc from emp e  </span><br><span class="line">   inner join  dept d on e.deptno &#x3D; d.deptno</span><br><span class="line">   where e.deptno &#x3D; 10 </span><br></pre></td></tr></table></div></figure>
<p>如果把上面的变成小于等于10的情况,用Join的方式合并的话会变成这样</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select e.name, d.loc from emp e  </span><br><span class="line">   inner join  dept d on e.deptno &#x3D; d.deptno</span><br><span class="line">   where (e.deptno &#x3D; 10) or (e.deptno &lt; 10)</span><br></pre></td></tr></table></div></figure>

        <h4 id="查找两个表相同的行并且连接多列"   >
          <a href="#查找两个表相同的行并且连接多列" class="heading-link"><i class="fas fa-link"></i></a>查找两个表相同的行并且连接多列</h4>
      <p>需求： 获取Clerk的信息，但是需要全部的列  </p>
<p>步骤： 1. 创建一个视图把Clerk的信息查出来<br>       2. 然后再去与emp表做Join获取完整的信息  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select e.empno, e.name, e.job, e.sal, e.deptno from emp e, </span><br><span class="line">(select ename, job, sal from emp where job &#x3D; &quot;CLERK&quot;) V </span><br><span class="line">where V.ename &#x3D; e.ename and </span><br><span class="line">      V.job &#x3D; e.job and </span><br><span class="line">      V.sal &#x3D; e.sal</span><br></pre></td></tr></table></div></figure>
<p>Join的处理手法  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select e.empno, e.name, e.job, e.sal, e.deptno from emp e</span><br><span class="line">join (select ename, job, sal from emp where job &#x3D; &quot;CLERK&quot;) V on (</span><br><span class="line">    V.ename &#x3D; e.ename</span><br><span class="line">    V.job &#x3D; e.job</span><br><span class="line">    V.sal &#x3D; e.sal)</span><br></pre></td></tr></table></div></figure>


        <h4 id="查询只存在于一个表中的数据"   >
          <a href="#查询只存在于一个表中的数据" class="heading-link"><i class="fas fa-link"></i></a>查询只存在于一个表中的数据</h4>
      <p>一般来说，直接使用not in 就可以了。但是对于如果含有Null的数据，就不能直接使用这样的方法处理。<br>那为什么null的数据就会出现问题呢？这个就要看一下他可能的实现方式<br>对于Mysql的实现， not in 和 in  本质上是  or的关系运算。 由于null 参与Or的逻辑运算方式不一致，In 和Not in 将产生不同的结果。  </p>
<p>此处默认表中有一条Null的数据</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; In</span><br><span class="line">select deptno from dept where deptno in (10, 50, null)</span><br><span class="line">~~~~~~~~~~</span><br><span class="line">Deptno</span><br><span class="line">--------</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">select deptno from dept where (deptno&#x3D;10 or deptno&#x3D;50 or deptno&#x3D;null)</span><br><span class="line">~~~~~~~~~~</span><br><span class="line">Deptno</span><br><span class="line">--------</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Not in </span><br><span class="line"></span><br><span class="line">select deptno from dept where deptno not in (10, 50, null)</span><br><span class="line">~~~~~~~~~~</span><br><span class="line">Deptno</span><br><span class="line">--------</span><br><span class="line">no rows</span><br><span class="line"></span><br><span class="line">select deptno from dept where deptno not  (deptno&#x3D;10 or deptno&#x3D;50 or deptno&#x3D;null)</span><br><span class="line">~~~~~~~~~~</span><br><span class="line">Deptno</span><br><span class="line">--------</span><br><span class="line">no rows</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>如果想要解决上面的null 所导致的问题， 需要结合Not exists 和关联子查询。 </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select d.deptno from dept d where</span><br><span class="line">not exists (select null from emp e where d.deptno &#x3D; e.deptno)</span><br><span class="line">~~~~~~~~~</span><br><span class="line">Deptno</span><br><span class="line">--------</span><br><span class="line">40</span><br></pre></td></tr></table></div></figure>


        <h4 id="确定两个表是否有相同的数据"   >
          <a href="#确定两个表是否有相同的数据" class="heading-link"><i class="fas fa-link"></i></a>确定两个表是否有相同的数据</h4>
      <!-- ![Union3](/assets/img/posts/sqlPost/Union-3.png) -->
<p>对于上面这种查询，可能会出现红色圈的数据重复的现象。那么我们要怎样才能确定是否有重复数据呢？  </p>
<img src="/2019/09/10/sql-revise/Union-3.png" class="" title="Union3">

<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create view v as </span><br><span class="line">select * from emp where deptno !&#x3D; 10</span><br><span class="line">union all </span><br><span class="line">select * from emp where ename &#x3D; &quot;ward&quot;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>处理手法使用关联子查询和UNION ALL 找出那些存在于视图V 而不存在于EMP 表的数据，以及存在于EMP 表而不存在于视图V 的数据，并将它们合并起来。  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  处理存在于EMP 不存于v的查询</span><br><span class="line">select * from (</span><br><span class="line">   select e.empno, e.ename, e.job, e.mgr, e.hiredate,</span><br><span class="line">          e.sal, e.comm, e.deptno, count(*) as cnt from emp e</span><br><span class="line">          group by empno, ename, job, mgr, hiredate,</span><br><span class="line">                   sal, comm, deptno) e </span><br><span class="line">) where not exists (</span><br><span class="line">   select null from (</span><br><span class="line">      select v.empno, v.ename, v.job, v.mgr, v.hiredate,</span><br><span class="line">          v.sal, v.comm, v.deptno, count(*) as cnt from v</span><br><span class="line">          group by empno, ename, job, mgr, hiredate,</span><br><span class="line">                   sal, comm, deptno) v</span><br><span class="line">      where v.empno &#x3D; e.empno and </span><br><span class="line">            v.ename &#x3D; e.ename and</span><br><span class="line">            v.job &#x3D; e.job and</span><br><span class="line">            v.mgr &#x3D; e.mgr and</span><br><span class="line">            v.hiredate &#x3D; e.hiredate and</span><br><span class="line">            v.sal &#x3D; e.sal and</span><br><span class="line">            v.deptno &#x3D; e.deptno and</span><br><span class="line">            v.cnt &#x3D; e.cnt and </span><br><span class="line">            coalesce(v.comm, 0) &#x3D; coalesce(e.comm, 0)</span><br><span class="line">   )  </span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  处理存在于V 不存于EMP的查询</span><br><span class="line">select * from (</span><br><span class="line">   select v.empno, v.ename, v.job, v.mgr, v.hiredate,</span><br><span class="line">          v.sal, v.comm, v.deptno, count(*) as cnt from v</span><br><span class="line">          group by empno, ename, job, mgr, hiredate,</span><br><span class="line">                   sal, comm, deptno) v</span><br><span class="line">) where not exists (</span><br><span class="line">   select null from (</span><br><span class="line">      select e.empno, e.ename, e.job, e.mgr, e.hiredate,</span><br><span class="line">          e.sal, e.comm, e.deptno, count(*) as cnt from v</span><br><span class="line">          group by empno, ename, job, mgr, hiredate,</span><br><span class="line">                   sal, comm, deptno) e</span><br><span class="line">      where v.empno &#x3D; e.empno and </span><br><span class="line">            v.ename &#x3D; e.ename and</span><br><span class="line">            v.job &#x3D; e.job and</span><br><span class="line">            v.mgr &#x3D; e.mgr and</span><br><span class="line">            v.hiredate &#x3D; e.hiredate and</span><br><span class="line">            v.sal &#x3D; e.sal and</span><br><span class="line">            v.deptno &#x3D; e.deptno and</span><br><span class="line">            v.cnt &#x3D; e.cnt and </span><br><span class="line">            coalesce(v.comm, 0) &#x3D; coalesce(e.comm, 0)</span><br><span class="line">   )  </span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 总体</span><br><span class="line">select * from (</span><br><span class="line">   select e.empno, e.ename, e.job, e.mgr, e.hiredate,</span><br><span class="line">          e.sal, e.comm, e.deptno, count(*) as cnt from emp e</span><br><span class="line">          group by empno, ename, job, mgr, hiredate,</span><br><span class="line">                   sal, comm, deptno) e </span><br><span class="line">) where not exists (</span><br><span class="line">   select null from (</span><br><span class="line">      select v.empno, v.ename, v.job, v.mgr, v.hiredate,</span><br><span class="line">          v.sal, v.comm, v.deptno, count(*) as cnt from v</span><br><span class="line">          group by empno, ename, job, mgr, hiredate,</span><br><span class="line">                   sal, comm, deptno) v</span><br><span class="line">      where v.empno &#x3D; e.empno and </span><br><span class="line">            v.ename &#x3D; e.ename and</span><br><span class="line">            v.job &#x3D; e.job and</span><br><span class="line">            v.mgr &#x3D; e.mgr and</span><br><span class="line">            v.hiredate &#x3D; e.hiredate and</span><br><span class="line">            v.sal &#x3D; e.sal and</span><br><span class="line">            v.deptno &#x3D; e.deptno and</span><br><span class="line">            v.cnt &#x3D; e.cnt and </span><br><span class="line">            coalesce(v.comm, 0) &#x3D; coalesce(e.comm, 0)</span><br><span class="line">   )  </span><br><span class="line">)</span><br><span class="line">Unoin all</span><br><span class="line">select * from (</span><br><span class="line">   select v.empno, v.ename, v.job, v.mgr, v.hiredate,</span><br><span class="line">          v.sal, v.comm, v.deptno, count(*) as cnt from v</span><br><span class="line">          group by empno, ename, job, mgr, hiredate,</span><br><span class="line">                   sal, comm, deptno) v</span><br><span class="line">) where not exists (</span><br><span class="line">   select null from (</span><br><span class="line">      select e.empno, e.ename, e.job, e.mgr, e.hiredate,</span><br><span class="line">          e.sal, e.comm, e.deptno, count(*) as cnt from v</span><br><span class="line">          group by empno, ename, job, mgr, hiredate,</span><br><span class="line">                   sal, comm, deptno) e</span><br><span class="line">      where v.empno &#x3D; e.empno and </span><br><span class="line">            v.ename &#x3D; e.ename and</span><br><span class="line">            v.job &#x3D; e.job and</span><br><span class="line">            v.mgr &#x3D; e.mgr and</span><br><span class="line">            v.hiredate &#x3D; e.hiredate and</span><br><span class="line">            v.sal &#x3D; e.sal and</span><br><span class="line">            v.deptno &#x3D; e.deptno and</span><br><span class="line">            v.cnt &#x3D; e.cnt and </span><br><span class="line">            coalesce(v.comm, 0) &#x3D; coalesce(e.comm, 0)</span><br><span class="line">   )  </span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>

        <h3 id="高级应用"   >
          <a href="#高级应用" class="heading-link"><i class="fas fa-link"></i></a>高级应用</h3>
      
        <h4 id="分页"   >
          <a href="#分页" class="heading-link"><i class="fas fa-link"></i></a>分页</h4>
      <p>可以使用Mysql 或者PG 内置的 limit 和 offset 进行处理 </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select sal from emp order by sal limit 5 offset 0</span><br><span class="line"></span><br><span class="line">select sal from emp order by sal limit 5 offset 5 </span><br></pre></td></tr></table></div></figure>

        <h4 id="间隔获取记录"   >
          <a href="#间隔获取记录" class="heading-link"><i class="fas fa-link"></i></a>间隔获取记录</h4>
      <p>对于没有默认编号的数据，我们需要先编号再进行过滤的操作<br>如果默认是已经有字段是序号的话，则采用直接Mod数据即可</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select x.name from (</span><br><span class="line">   select a.ename , (</span><br><span class="line">      select count(*) from emp b where</span><br><span class="line">      b.ename &lt;&#x3D; a.ename</span><br><span class="line">   ) as rn from emp a </span><br><span class="line">) x where mod(rn,2) &#x3D; 1</span><br></pre></td></tr></table></div></figure>

        <h4 id="外查询使用OR逻辑"   >
          <a href="#外查询使用OR逻辑" class="heading-link"><i class="fas fa-link"></i></a>外查询使用OR逻辑</h4>
      <ol>
<li>先去Join表，然后再去进行Or的逻辑判断<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select e.ename, d.deptno , d.dname, d.loc from dept d </span><br><span class="line">left join emp e on (d.deptno &#x3D; e.deptno</span><br><span class="line">                    and (e.deptno&#x3D;10 or e.deptno&#x3D;20))</span><br><span class="line">order by 2 </span><br></pre></td></tr></table></div></figure></li>
<li>先创建一个中间表，然后再去进行Join的操作</li>
</ol>
<p>select e.ename, d.deptno , d.dname, d.loc from dept d<br>left join (select * from emp e where e.deptno=10 or e.deptno=20)<br>on d.deptno = e.deptno order by 2 </p>

        <h4 id="对单表需要做数据运算情况"   >
          <a href="#对单表需要做数据运算情况" class="heading-link"><i class="fas fa-link"></i></a>对单表需要做数据运算情况</h4>
      <p>情况1： 找出互逆的记录（本例）<br>情况2： 查找表中某列1相差为1，并且某列2差为5的记录  </p>
<p>总体的思路，把自己与自己(或者与自己的子集)求笛卡尔积，然后去进行条件的筛选</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select distinct v1.* from V v1, V v2 where</span><br><span class="line">        v1.test1 &#x3D; v2.test2</span><br><span class="line">        and v1.test2 &#x3D; v2.test1</span><br><span class="line">        and v1.test1 &lt;&#x3D; v1.test2</span><br></pre></td></tr></table></div></figure>

        <h4 id="找出最靠前的N条记录"   >
          <a href="#找出最靠前的N条记录" class="heading-link"><i class="fas fa-link"></i></a>找出最靠前的N条记录</h4>
      <p>此处使用了标量子查询来创建了一张临时表的RNK的列</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; </span><br><span class="line">select ename, sal from (</span><br><span class="line">   select (</span><br><span class="line">      select (count(distinct b.sal) from emp b where </span><br><span class="line">             a.sal &lt;&#x3D; b.sal) as rnk,</span><br><span class="line">             a.sal,</span><br><span class="line">             a.ename</span><br><span class="line">   ) from emp a </span><br><span class="line">) where rnk &lt;&#x3D;5</span><br></pre></td></tr></table></div></figure>



        <h2 id="OrderBy"   >
          <a href="#OrderBy" class="heading-link"><i class="fas fa-link"></i></a>OrderBy</h2>
      
        <h3 id="基础查询"   >
          <a href="#基础查询" class="heading-link"><i class="fas fa-link"></i></a>基础查询</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 升序查询</span><br><span class="line">select * from emp order by col2 asc;</span><br><span class="line">&#x2F;&#x2F; 降序查询</span><br><span class="line">select * from emp order by col2 desc;</span><br></pre></td></tr></table></div></figure>

        <h3 id="多字段排序"   >
          <a href="#多字段排序" class="heading-link"><i class="fas fa-link"></i></a>多字段排序</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select empno, deptno, sal, ename, job from emp order by deptno (asc), sal desc;</span><br></pre></td></tr></table></div></figure>

        <h3 id="动态排序"   >
          <a href="#动态排序" class="heading-link"><i class="fas fa-link"></i></a>动态排序</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select ename, sal, job, comm from emp order by </span><br><span class="line">       case when job &#x3D; &quot;salesman&quot; then comm</span><br><span class="line">            else  sal </span><br><span class="line">       end;</span><br></pre></td></tr></table></div></figure>


        <h2 id="update"   >
          <a href="#update" class="heading-link"><i class="fas fa-link"></i></a>update</h2>
      
        <h3 id="基础语法"   >
          <a href="#基础语法" class="heading-link"><i class="fas fa-link"></i></a>基础语法</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update table name set col_name &#x3D; xxx where $cond</span><br></pre></td></tr></table></div></figure>

        <h2 id="delete"   >
          <a href="#delete" class="heading-link"><i class="fas fa-link"></i></a>delete</h2>
      <p>基础语法  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from table_name where $cond</span><br></pre></td></tr></table></div></figure>
<p>删除重复记录</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from table where id not in (select min(id) from table group by name)</span><br></pre></td></tr></table></div></figure>

        <h1 id="Having-amp-GroupBy"   >
          <a href="#Having-amp-GroupBy" class="heading-link"><i class="fas fa-link"></i></a>Having &amp; GroupBy</h1>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wiki原文</span><br><span class="line">A HAVING clause in SQL specifies that an SQL SELECT statement should only return rows where aggregate values meet the specified conditions. It was added to the SQL language because the WHERE keyword could not be used with aggregate functions.</span><br><span class="line">The HAVING clause filters the data on the group row but not on the individual row.</span><br><span class="line">To view the present condition formed by the GROUP BY clause, the HAVING clause is used.</span><br></pre></td></tr></table></div></figure>
<p>Having的语句是必须要在GroupBy后面才能使用。并且与Where的区别是，Where不能直接接入聚合的函数（如Sum()、Count()、Avg()） 这种的聚合函数， 意思是不能 where sum(column_a) 这样的用法）, 并且Having可以对按Group区分的Row进行过滤的操作</p>
<p>所以常规语法一般是</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table_a A group by columa_a having count (A.column_a ) &gt; 200</span><br></pre></td></tr></table></div></figure>

        <h1 id="特殊注意"   >
          <a href="#特殊注意" class="heading-link"><i class="fas fa-link"></i></a>特殊注意</h1>
      <ol>
<li>类似于Sum， max， min , avg 这些也是可以直接用于select 的条件上面的<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select max(Salary) as SecondHighestSalary from employee where salary&lt;(select max(distinct(salary)) from employee)</span><br></pre></td></tr></table></div></figure></li>
<li>sql 三元运算符<br>if (expr1, expr2, expr3)<br>跟正常编程语言中的三元运算符一致，只是语法有变动。也是满足条件一，则返回expr2，否则返回expr3</li>
</ol>

        <h1 id="ShareNote"   >
          <a href="#ShareNote" class="heading-link"><i class="fas fa-link"></i></a>ShareNote</h1>
      <ol>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins" >Visual-Representation-of-SQL</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Having_(SQL)" >Having-Sql-Cluse-wiki</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://book.douban.com/subject/30259463/" >Sql经典实例</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.ituring.com.cn/book/miniarticle/47448" >Sql基础教程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/09/03/go-slice/">Go语言切片技巧</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-09-03</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-01-22</span></span></div></header><div class="post-body"><div class="post-excerpt"><!-- ---
layout: post
title: 
author: Ray Chan(ray1888)
date: '2019-09-03 10:07:38 +0800'
category: go
summary: Go Slice 
thumbnail: go.png
--- -->




        <h1 id="添加元素到切片中"   >
          <a href="#添加元素到切片中" class="heading-link"><i class="fas fa-link"></i></a>添加元素到切片中</h1>
      
        <h2 id="添加元素到尾部"   >
          <a href="#添加元素到尾部" class="heading-link"><i class="fas fa-link"></i></a>添加元素到尾部</h2>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a []int</span><br><span class="line">&#x2F;&#x2F;  添加元素(后面的元素都需要解包）</span><br><span class="line">append(a, 0)</span><br><span class="line">&#x2F;&#x2F; 添加切片(后面的元素都需要解包）</span><br><span class="line">append(a, []int&#123;1,2,3&#125;...)</span><br></pre></td></tr></table></div></figure>

        <h2 id="添加元素到头部"   >
          <a href="#添加元素到头部" class="heading-link"><i class="fas fa-link"></i></a>添加元素到头部</h2>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a []int</span><br><span class="line">&#x2F;&#x2F;  添加元素(后面的元素都需要解包）  </span><br><span class="line">a &#x3D; append([]int&#123;1&#125;, a...)</span><br><span class="line">&#x2F;&#x2F; 添加切片(后面的元素都需要解包）  </span><br><span class="line">a &#x3D; append([]int&#123;1,2,3&#125;, a...)  </span><br></pre></td></tr></table></div></figure>

        <h2 id="添加指定元素到切片中"   >
          <a href="#添加指定元素到切片中" class="heading-link"><i class="fas fa-link"></i></a>添加指定元素到切片中</h2>
      <p>性能较低的方法（会产生中间过渡切片）  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a []int</span><br><span class="line">a &#x3D; append(a[:i], append([]int&#123;1,2&#125;, a[i:]...)...)  &#x2F;&#x2F; 在第i个元素插入切片</span><br><span class="line">a &#x3D; append(a[:i], append([]int&#123;1&#125;, a[i:]...)...)     &#x2F;&#x2F;  在第i个元素插入元素</span><br></pre></td></tr></table></div></figure>
<p>性能较高的方法</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  插入单个元素</span><br><span class="line">a &#x3D; append(a, 0)</span><br><span class="line">copy(a[i+1:],  a[i:])</span><br><span class="line">a[i] &#x3D; x </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  添加多个元素(一个切片）</span><br><span class="line">&#x2F;&#x2F;  b&#x3D; []int&#123;1,2,3&#125;</span><br><span class="line">a &#x3D; append(a,b..)</span><br><span class="line">copy(a[i+len(b):],  a[i:])</span><br><span class="line">copy(a[i:], b) </span><br></pre></td></tr></table></div></figure>


        <h1 id="删除切片元素"   >
          <a href="#删除切片元素" class="heading-link"><i class="fas fa-link"></i></a>删除切片元素</h1>
      
        <h2 id="删除结尾元素"   >
          <a href="#删除结尾元素" class="heading-link"><i class="fas fa-link"></i></a>删除结尾元素</h2>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; []int&#123;1,2,3&#125;</span><br><span class="line">&#x2F;&#x2F; 删除单个元素</span><br><span class="line">a &#x3D; a[:len(a)-1]</span><br><span class="line">&#x2F;&#x2F; 删除多个元素</span><br><span class="line">a &#x3D; a[:len(a)-N]</span><br></pre></td></tr></table></div></figure>

        <h2 id="删除开头元素"   >
          <a href="#删除开头元素" class="heading-link"><i class="fas fa-link"></i></a>删除开头元素</h2>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; []int&#123;1,2,3&#125;</span><br><span class="line">&#x2F;&#x2F; 删除单个元素</span><br><span class="line">a &#x3D; a[1:]</span><br><span class="line">&#x2F;&#x2F; 删除多个元素</span><br><span class="line">a &#x3D; a[N:]</span><br></pre></td></tr></table></div></figure>

<p>不移动指针的方法(把后面元素往前移动)， 用到了空指针  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; []int&#123;1,2,3&#125;</span><br><span class="line">&#x2F;&#x2F; 删除单个元素</span><br><span class="line">a &#x3D; append(a[:0], a[1:]...)  </span><br><span class="line">&#x2F;&#x2F; 删除多个元素</span><br><span class="line">a &#x3D;  append(a[:0], a[N:]...)  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  使用Copy来进行处理</span><br><span class="line">a &#x3D; []int&#123;1,2,3&#125;</span><br><span class="line">a &#x3D; a[:copy(a, a[1:])]</span><br><span class="line">a &#x3D; a[:copy(a, a[N:])]</span><br></pre></td></tr></table></div></figure>

        <h2 id="删除中间元素"   >
          <a href="#删除中间元素" class="heading-link"><i class="fas fa-link"></i></a>删除中间元素</h2>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; []int&#123;1,2,3,4,5&#125;</span><br><span class="line">a &#x3D; append(a[:i], a[i+1:]...)</span><br><span class="line">a &#x3D; append(a[:i], a[i+N:]...)</span><br><span class="line"></span><br><span class="line">a &#x3D; a[:i+copy(a[i:], a[i+1:])]</span><br><span class="line">a &#x3D; a[:i+copy(a[i:], a[i+N:])]</span><br></pre></td></tr></table></div></figure>

        <h1 id="切片的实现原理及使用的注意事项"   >
          <a href="#切片的实现原理及使用的注意事项" class="heading-link"><i class="fas fa-link"></i></a>切片的实现原理及使用的注意事项</h1>
      <p>切片本质上是对底层数组的一个数据的引用。但是它是一个动态的结构。它的底层结构是这样的  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type SliceHeader struct&#123;</span><br><span class="line">    Data uintptr</span><br><span class="line">    Len   int  &#x2F;&#x2F;  实际已经使用的容量</span><br><span class="line">    Cap   int  &#x2F;&#x2F;  最大的容量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<!-- ![goSlice](/assets/img/posts/GoSlice.png) -->
<img src="/2019/09/03/go-slice/GoSlice.png" class="" title="goSlice">


<p>可以看出实际上这两个切片都是指向同一个数组的。但是如果当切片进行扩展后，会变成这样。  </p>
<!-- ![goSliceE](/assets/img/posts/GoSliceExtend.png) -->
<img src="/2019/09/03/go-slice/GoSliceExtend.png" class="" title="goSliceE">


<p>可以看出，因为原来的底层数组因为长度已经不足以Slice进行扩展，因此Slice会先去创建一个新的底层数组，并且把原来的元素加入到新创建的数组中，并且再把新插入的元素插入到新数组中。然后把原来指向的底层数组的Reference Count 减一。  </p>

        <h2 id="使用的技巧"   >
          <a href="#使用的技巧" class="heading-link"><i class="fas fa-link"></i></a>使用的技巧</h2>
      <ol>
<li>因为如果append进去切片的时候，len = cap 就会出现内存的申请和数据的复制，这样会使得比较慢。使用时尽量去减少触发内存分配的次数和分配内存的大小。</li>
<li>对于切片来说，即使是空切片，cap=0, len=0, 它实际上也不会是nil, 因此判断一个切片是否为空，应该使用len($slice_name) == 0 来继续判断。</li>
</ol>

        <h2 id="切片GC的问题"   >
          <a href="#切片GC的问题" class="heading-link"><i class="fas fa-link"></i></a>切片GC的问题</h2>
      <p>一个比较经常的情况，对底层数组的某一个内存的引用，导致整个数组无法被GC。</p>

        <h3 id="变量引用的情况"   >
          <a href="#变量引用的情况" class="heading-link"><i class="fas fa-link"></i></a>变量引用的情况</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func FindPhoneNumber(filename string) []byte&#123;</span><br><span class="line">	b, _ :&#x3D; ioutil.ReadFile(filename)</span><br><span class="line">	return regexp.MustCompile(&quot;[0-9]+&quot;).Find(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>上面的这段代码里面，因为返回的地方是一个切片引用了b的底层数组，导致b的底层数组会一直在内存中。  </p>
<p>解决上面的问题，可以使用传值把需要用到的值传到一个新的切片里面，这样就能减少依赖。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func FindPhoneNumber(filename string) []byte&#123;</span><br><span class="line">	b, _ :&#x3D; ioutil.ReadFile(filename)</span><br><span class="line">	b &#x3D;  regexp.MustCompile(&quot;[0-9]+&quot;).Find(b)</span><br><span class="line">    return append([]byte&#123;&#125;, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="删除变量的情况"   >
          <a href="#删除变量的情况" class="heading-link"><i class="fas fa-link"></i></a>删除变量的情况</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a *[]int&#123;1,2,3,4,4,5,6&#125;</span><br><span class="line">a &#x3D; a[:len(a)-1] &#x2F;&#x2F; 被删除的最后一个元素仍然被引用</span><br></pre></td></tr></table></div></figure>
<p>保险的处理方法, 把需要删除的元素设置为nil，然后再去进行切片</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a *[]int&#123;1,2,3,4,4,5,6&#125;</span><br><span class="line">a[len(a)-1] &#x3D; nil</span><br><span class="line">a &#x3D; a[:len(a)-1] &#x2F;&#x2F; 被删除的最后一个元素仍然被引用</span><br></pre></td></tr></table></div></figure></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/08/29/raft-lab-4/">MIT6.824 Lab4 实现及解析</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-08-29</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-01-22</span></span></div></header><div class="post-body"><div class="post-excerpt"><!-- ---
layout: post
title: MIT6.824 Lab4 实现及解析
author: Ray Chan(ray1888)
date: '2019-08-20 12:05:38 +0800'
category: distributed-system
summary: MIT6.824 Lab4 Implemantation and detail explains
thumbnail: distributed-db.jpg
--- -->


        <h1 id="目录"   >
          <a href="#目录" class="heading-link"><i class="fas fa-link"></i></a>目录</h1>
      <ol>
<li><a href="#Purpose">实验目的</a>  </li>
<li><a href="#Implementation">实验实现</a><br>2.1 <a href="#2.1">lab4-1</a><br>2.2 <a href="#2.2">lab4-2</a>  </li>
</ol>

        <h1 id="实验目的"   >
          <a href="#实验目的" class="heading-link"><i class="fas fa-link"></i></a>实验目的</h1>
      <p>lab4需要实现两个模块:</p>
<ol>
<li>lab4-1 完成一个基于KvRaft的ShardMaster（可以理解为一个分片调度的存放的机器），但是写入的是配置而不是简单的K-v的值（但是与Lab3的实现相当相似）</li>
<li>lab4-2 完成一个Sharding的kvRaft数据库（实现了Multi-raft)</li>
</ol>
<p>整体的实验架构是这样的</p>
<!-- ![lab4](/assets/img/posts/lab4.png) -->
<img src="/2019/08/29/raft-lab-4/lab4.png" class="" title="lab4">

<p>架构图如上：<br>一个值得注意的点是，各个KV数据库层之间不会直接相互通信，只是会通过Raft层来同步操作。<br>并且Client如果找到的不是Leader的节点，会直接放弃操作。然后请求集群内的下一个节点。<br>PS: 这里的KvDatabase 和Raft总体包起来才是一个KVServer的实例，而不是单独脱离的。    </p>
<p>流程大概如下:</p>
<ol>
<li>Client发送请求到ShardMaster，查询Key的具体对应的分片在哪个组里面</li>
<li>ShardMaster收到请求后，返回对应数据Key所在的组信息</li>
<li>Client发送请求到对应分片的Raft Leader中</li>
<li>Raft层同步成功后，会通过ApplyCh返回信号的KvDatabase</li>
<li>分片的KvDatabase对Client端做出应答（如果成功返回结果为成功，如果下面同步层失败导致超时，返回给客户端的结果为超时）</li>
</ol>

        <h2 id="副本与分片的问题"   >
          <a href="#副本与分片的问题" class="heading-link"><i class="fas fa-link"></i></a>副本与分片的问题</h2>
      <p>在上面的架构图中，Multi-Raft已经实现了分片的副本的实现。</p>
<p>分片： 只要是把数据进行划分（从大的数据变为只负责一部分的数据量）即是分片（在定义上面数据库的垂直划分和水平划分和此处的Key按键去Mod划分都是属于分片的操作，但是数据库表的划分和此处的Key的Mod划分不是在同一个层级上面的，理解不一样）<br>副本： 是指数据的重复的数量。但是一般只有一份的数据我们不会称之为单副本，而是称为0副本。副本一般是&gt;=2才叫。副本的目的是为了冗余的问题。防止因为单点故障而导致数据全部的丢失。  </p>

        <h1 id="实验实现"   >
          <a href="#实验实现" class="heading-link"><i class="fas fa-link"></i></a>实验实现</h1>
      
        <h2 id="lab4-1"   >
          <a href="#lab4-1" class="heading-link"><i class="fas fa-link"></i></a>lab4-1</h2>
      <p>对比起与Lab3 的实现，它在这里需要支持的是Leave(), Move(), Join()， Query()的四种方法，因为分别对应节点的加入集群、退出集群、移动集群和集群配置查询的四种操作。<br>所以基本实现的思路与Lab3是类似的。  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type ShardMaster struct &#123;</span><br><span class="line">	mu      sync.Mutex</span><br><span class="line">	me      int</span><br><span class="line">	rf      *raft.Raft</span><br><span class="line">	applyCh chan raft.ApplyMsg</span><br><span class="line">	&#x2F;&#x2F; Your data here.</span><br><span class="line">    &#x2F;&#x2F; Lab3 此处是为database 是一个map[string]string 的结构</span><br><span class="line">	configs    []Config &#x2F;&#x2F; indexed by config num</span><br><span class="line">	dup        map[int64]Result</span><br><span class="line">	chanResult map[int]chan Result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>但是有一个比较重要的需求是，它需要完成一个shard 与 集群的绑定关系的变动，因为本来就是需要支持的目的就是数据随着Group的添加和变动来做到数据的均衡。<br>并且一个比较不同的是，对于重复的Get操作操作，Lab3采用的是直接返回Kv的值，但是在此处，因为Config的存放机制是一个数组（里面的顺序就是配置有效的顺序），因此需要把重复的读配置，返回一个复制好的配置。  </p>

        <h2 id="lab4-2"   >
          <a href="#lab4-2" class="heading-link"><i class="fas fa-link"></i></a>lab4-2</h2>
      <p>这里的实现是需要首先保证Kv的功能可以使用，然后保证在配置变动并且数据搬移完成之后，才能继续对外提供Kv的服务。并且需要保证节点挂掉之后可以读取会最新的状态下来</p>
<p>总体流程：<br>在提供KV服务的同时，需要把配置定时进行更新，并且实际应用新配置之前，必须保证数据迁移成功。因此实际上用到了3个单独的协程去分别做这几个工作</p>
<ol>
<li>读取配置协程（定时向ShardMaster请求配置）</li>
<li>数据迁移的协程</li>
<li>应用数据同步的协程</li>
</ol>
<p>因为这个实验中的目的有三种，因此我们的消息类型也定义了三种</p>
<ol>
<li>数据操作类型，与Lab3原来类似的OP类型（可以包含Get、Pull、Put、Append的操作）</li>
<li>配置更新类型，把Lab4-1的Config类型封装一层进行使用</li>
<li>真实的数据迁移类型，原因是：因为数据迁移的时候是两个RaftGroup的Leader相互通信，并且需要把原来数据KV格式同步进去到新的组的所有副本上面。因此单独分配一个数据类型来记录此类数据</li>
</ol>
<p>向ShardMaster读取配置的协程的实现</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func (kv *ShardKV) ConfigUpdateRoutine() &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		kv.mu.Lock()</span><br><span class="line">		curConfigNum :&#x3D; kv.myconfig[0].Num</span><br><span class="line">		kv.mu.Unlock()</span><br><span class="line">        &#x2F;&#x2F; 此处Query带上当前版本加1的原因，防止查询到的配置不正确，导致分片的节点之前一直无法达成配置上共识</span><br><span class="line">		config :&#x3D; kv.mck.Query(curConfigNum + 1)</span><br><span class="line">		&#x2F;&#x2F;DPrintf(&quot;get newConfig from SM group is %v, shard is %v&quot;, config.Groups, config.Shards)</span><br><span class="line">		kv.mu.Lock()</span><br><span class="line">		if config.Num &#x3D;&#x3D; kv.myconfig[0].Num+1 &#123;</span><br><span class="line">			&#x2F;&#x2F; update with static NewConfig</span><br><span class="line">			newConfig :&#x3D; kv.makeEmptyConfig()</span><br><span class="line">			kv.CopyConfig(&amp;config, &amp;newConfig)</span><br><span class="line">			if _, isLeader :&#x3D; kv.rf.GetState(); isLeader &#123;</span><br><span class="line">				cfg :&#x3D; Cfg&#123;newConfig, int64(kv.gid), kv.myconfig[0].Num&#125;</span><br><span class="line">				kv.rf.Start(cfg)</span><br><span class="line">				DPrintf(&quot;Config: group %d-%d is start config %d into consueum&quot;,</span><br><span class="line">					kv.gid, kv.me, cfg.NewConfig.Num)</span><br><span class="line">				&#x2F;&#x2F;index, _, isleader :&#x3D; kv.rf.Start(cfg)</span><br><span class="line">				&#x2F;&#x2F;DPrintf(&quot;))))) server %d gid %d Start cfg， index is %d, isleader is %t, kv is %v&quot;,</span><br><span class="line">				&#x2F;&#x2F;	kv.me, kv.gid, index, isleader, kv.database)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		kv.mu.Unlock()</span><br><span class="line">		time.Sleep(100 * time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>修改自己需要发送和接受Shard的配置部分的代码</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">case Cfg:</span><br><span class="line">    if kv.CfgDupCheck(cmd.ClientId, cmd.Seq) &#123;</span><br><span class="line">        kv.SwitchConfig(cmd)</span><br><span class="line">        if kv.CheckMigrateDone() &#123;</span><br><span class="line">            &#x2F;&#x2F; if migrate done, use new config, if not, do nothing to avoid replying the old group replied</span><br><span class="line">            kv.myconfig[0] &#x3D; kv.myconfig[1]</span><br><span class="line">            &#x2F;&#x2F;DPrintf(&quot;group %d-%d is applied new config , shard is %v, kv is %v&quot;, kv.gid, kv.me, kv.myshards, kv.database)</span><br><span class="line">        &#125;</span><br><span class="line">        kv.cfgdup[cmd.ClientId] &#x3D; cmd.Seq</span><br><span class="line">        if kv.maxraftstate !&#x3D; -1 &#123;</span><br><span class="line">            kv.SaveSnapshot(index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">func (kv *ShardKV) SwitchConfig(newcfg Cfg) &#123;</span><br><span class="line">	if newcfg.NewConfig.Num &#x3D;&#x3D; kv.myconfig[0].Num+1 &#123;</span><br><span class="line">		if kv.myconfig[0].Num !&#x3D; 0 &#123;</span><br><span class="line">			kv.GenShardChangeList(newcfg)</span><br><span class="line">		&#125; else if kv.myconfig[0].Num &#x3D;&#x3D; 0 &#123;</span><br><span class="line">			for i :&#x3D; 0; i &lt; shardmaster.NShards; i++ &#123;</span><br><span class="line">				if newcfg.NewConfig.Shards[i] &#x3D;&#x3D; kv.gid &#123;</span><br><span class="line">					kv.myshards[i] &#x3D; 1</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		newc :&#x3D; kv.makeEmptyConfig()</span><br><span class="line">		kv.CopyConfig(&amp;newcfg.NewConfig, &amp;newc)</span><br><span class="line">		kv.myconfig[1] &#x3D; newc</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 此函数是用于生成需要发送和修改那些部分的参数</span><br><span class="line">func (kv *ShardKV) GenShardChangeList(newcfg Cfg) &#123;</span><br><span class="line">	for i :&#x3D; 0; i &lt; shardmaster.NShards; i++ &#123;</span><br><span class="line">		if kv.myconfig[0].Shards[i] &#x3D;&#x3D; kv.gid &amp;&amp; newcfg.NewConfig.Shards[i] !&#x3D; kv.gid &#123;</span><br><span class="line">			&#x2F;&#x2F;need to send</span><br><span class="line">			kv.needsend[i] &#x3D; newcfg.NewConfig.Shards[i]</span><br><span class="line">		&#125;</span><br><span class="line">		if kv.myconfig[0].Shards[i] !&#x3D; kv.gid &amp;&amp; newcfg.NewConfig.Shards[i] &#x3D;&#x3D; kv.gid &#123;</span><br><span class="line">			&#x2F;&#x2F;need to recv</span><br><span class="line">			_, ok :&#x3D; kv.needrecv[kv.myconfig[0].Shards[i]]</span><br><span class="line">			if !ok &#123;</span><br><span class="line">				kv.needrecv[kv.myconfig[0].Shards[i]] &#x3D; make([]int, 0)</span><br><span class="line">			&#125;</span><br><span class="line">			kv.needrecv[kv.myconfig[0].Shards[i]] &#x3D; append(kv.needrecv[kv.myconfig[0].Shards[i]], i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	DPrintf(&quot;!!! group %d-%d, new config need to send is %v, need to receive is %v&quot;, kv.gid, kv.me, kv.needsend, kv.needrecv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>获取迁移的数据部分<br>数据迁移的副本是只要检测到相关属性的变化之后（感知到数据的变化）后，新的数据所归属的Leader就会与旧Leader继续RPC的Pull调用， 去获取它的Database和DUP的部分<br>当拉取到配置了之后，就会把数据变成日志应用到状态中，就可以实现分片数据的副本的性质。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">func (kv *ShardKV) MigrationRoutine() &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		if _, isLeader :&#x3D; kv.rf.GetState(); isLeader &#123;</span><br><span class="line">			kv.mu.Lock()</span><br><span class="line">			for k, v :&#x3D; range kv.needrecv &#123;</span><br><span class="line">				&#x2F;&#x2F;DPrintf(&quot;group %d-%d needrecv &quot;)</span><br><span class="line">				needshard :&#x3D; make([]int, 0)</span><br><span class="line">				for i :&#x3D; 0; i &lt; len(v); i++ &#123;</span><br><span class="line">					needshard &#x3D; append(needshard, v[i])</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				args :&#x3D; PullArgs&#123;Shard: needshard, ClientId: int64(kv.gid), Seq: kv.myconfig[0].Num&#125;</span><br><span class="line">				go func(mgid int, arg *PullArgs) &#123;</span><br><span class="line">					servers :&#x3D; kv.myconfig[0].Groups[mgid]</span><br><span class="line">					DPrintf(&quot;Migrate: group %d-%d get Gid %d Servers is %v&quot;,</span><br><span class="line">						kv.gid, kv.me, mgid, servers)</span><br><span class="line">					for &#123;</span><br><span class="line">						for _, si :&#x3D; range servers &#123;</span><br><span class="line">							reply :&#x3D; PullReply&#123;&#125;</span><br><span class="line">							srv :&#x3D; kv.make_end(si)</span><br><span class="line">							DPrintf(&quot;group %d-%d start call to gid %d&quot;, kv.gid, kv.me, mgid)</span><br><span class="line">                            &#x2F;&#x2F; 由GroupA</span><br><span class="line">							ok :&#x3D; srv.Call(&quot;ShardKV.Pull&quot;, arg, &amp;reply)</span><br><span class="line">							&#x2F;&#x2F;DPrintf(&quot;Migrate: group %d-%d  calling for server %v rpc pull, result is %t&quot;,</span><br><span class="line">							&#x2F;&#x2F;	    kv.gid, kv.me, si, ok)</span><br><span class="line">							if !ok &#123;</span><br><span class="line">								DPrintf(&quot;Migrate Failed: group %d-%d  calling for server %v rpc pull, result is %t&quot;,</span><br><span class="line">									kv.gid, kv.me, si, ok)</span><br><span class="line">							&#125;</span><br><span class="line">							if ok &amp;&amp; reply.WrongLeader &#x3D;&#x3D; false &#123;</span><br><span class="line">								if reply.Err &#x3D;&#x3D; ErrNeedWait &#123;</span><br><span class="line">									DPrintf(&quot;Migrate: waiting server %v to pull new config from SM&quot;, si)</span><br><span class="line">									return</span><br><span class="line">								&#125;</span><br><span class="line">								if _, isleader :&#x3D; kv.rf.GetState(); isleader &#123;</span><br><span class="line">									newmapkv :&#x3D; make(map[string]string)</span><br><span class="line">									for k, v :&#x3D; range reply.MapKV &#123;</span><br><span class="line">										newmapkv[k] &#x3D; v</span><br><span class="line">									&#125;</span><br><span class="line">									var newdup [shardmaster.NShards]map[int64]int</span><br><span class="line">									for i :&#x3D; 0; i &lt; shardmaster.NShards; i++ &#123;</span><br><span class="line">										newdup[i] &#x3D; make(map[int64]int)</span><br><span class="line">										for k, v :&#x3D; range reply.ShardDup[i] &#123;</span><br><span class="line">											newdup[i][k] &#x3D; v</span><br><span class="line">										&#125;</span><br><span class="line">									&#125;</span><br><span class="line">									mig :&#x3D; Migrate&#123;newmapkv, newdup, arg.Seq, mgid&#125;</span><br><span class="line">									kv.mu.Lock()</span><br><span class="line">									&#x2F;&#x2F; this is how partition data can be repliacated</span><br><span class="line">									kv.rf.Start(mig)</span><br><span class="line">									DPrintf(&quot;Migrate: group %d-%d start migrate the data pulled from %d&quot;, kv.gid, kv.me, mgid)</span><br><span class="line">									kv.mu.Unlock()</span><br><span class="line">									return</span><br><span class="line">								&#125;</span><br><span class="line">							&#125; else &#123;</span><br><span class="line">								DPrintf(&quot;Migrate Failed: group %d-%d call %d-%v meet wrong leader&quot;,</span><br><span class="line">									kv.gid, kv.me, mgid, si)</span><br><span class="line">								DPrintf(&quot;!!!server is %v&quot;, servers)</span><br><span class="line">							&#125;</span><br><span class="line">							time.Sleep(20 * time.Millisecond)</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;(k, &amp;args)</span><br><span class="line">			&#125;</span><br><span class="line">			kv.mu.Unlock()</span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(100 * time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>非Leader节点同步KV数据的方法</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">case Migrate:</span><br><span class="line">    if kv.MigrateDupCheck(cmd.Gid, cmd.Num) &#123;</span><br><span class="line">        &#x2F;&#x2F;DPrintf(&quot;group %d-%d apply the migrate data from %d and config num %d&quot;, kv.gid, kv.me, cmd.Gid, cmd.Num)</span><br><span class="line">        &#x2F;&#x2F;DPrintf(&quot;group %d-%d database before migrate is %v&quot;, kv.gid, kv.me, kv.database)</span><br><span class="line">        for k, v :&#x3D; range cmd.MapKV &#123;</span><br><span class="line">            kv.database[k] &#x3D; v</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;DPrintf(&quot;group %d-%d database after migrate is %v&quot;, kv.gid, kv.me, kv.database)</span><br><span class="line">        for i :&#x3D; 0; i &lt; shardmaster.NShards; i++ &#123;</span><br><span class="line">            for k, v :&#x3D; range cmd.ShardDup[i] &#123;</span><br><span class="line">                kv.dup[i][k] &#x3D; v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for i :&#x3D; 0; i &lt; len(kv.needrecv[cmd.Gid]); i++ &#123;</span><br><span class="line">            kv.myshards[kv.needrecv[cmd.Gid][i]] &#x3D; 1</span><br><span class="line">        &#125;</span><br><span class="line">        delete(kv.needrecv, cmd.Gid)</span><br><span class="line">        if kv.CheckMigrateDone() &#123;</span><br><span class="line">            kv.myconfig[0] &#x3D; kv.myconfig[1]</span><br><span class="line">            DPrintf(&quot;Migrate: group %d-%d successful switch to config %d&quot;, kv.gid, kv.me, kv.myconfig[0].Num)</span><br><span class="line">            &#x2F;&#x2F;DPrintf(&quot;group %d-%d is applied new config , shard is %v&quot;, kv.gid, kv.me, kv.myshards)</span><br><span class="line">        &#125;</span><br><span class="line">        kv.migratedup[cmd.Gid] &#x3D; cmd.Num</span><br><span class="line">        if kv.maxraftstate !&#x3D; -1 &#123;</span><br><span class="line">            kv.SaveSnapshot(index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/08/29/raft-lab-3/">MIT6.824 Lab3 实现及解析</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-08-29</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-01-22</span></span></div></header><div class="post-body"><div class="post-excerpt"><!-- ---
layout: post
title:
author: Ray Chan(ray1888)
date: '2019-08-20 12:05:38 +0800'
category: 
summary: MIT6.824 Lab3 Implemantation and detail explains
thumbnail: distributed-db.jpg
--- -->


        <h1 id="目录"   >
          <a href="#目录" class="heading-link"><i class="fas fa-link"></i></a>目录</h1>
      <ol>
<li>实验目的</li>
<li>实验实现</li>
</ol>

        <h1 id="实验目的"   >
          <a href="#实验目的" class="heading-link"><i class="fas fa-link"></i></a>实验目的</h1>
      <p>lab3需要实现一个建议的带客户端的 分布式KV的数据库，需要支持对外的Get(), Put(), Append()三个操作</p>
<p>整体的实验架构是这样的</p>
<!-- ![lab3](/assets/img/posts/Lab3-Process.png) -->
<img src="/2019/08/29/raft-lab-3/Lab3-Process.png" class="" title="lab3">
<p>架构图如上：<br>一个值得注意的点是，各个KV数据库层之间不会直接相互通信，只是会通过Raft层来同步操作。<br>并且Client如果找到的不是Leader的节点，会直接放弃操作。然后请求集群内的下一个节点。<br>PS: 这里的KvDatabase 和Raft总体包起来才是一个KVServer的实例，而不是单独脱离的。  </p>
<p>流程大概如下:</p>
<ol>
<li>Client发送请求到KvDatabase</li>
<li>KvDatabase收到请求后，会把收到的命令重新封装，通过Raft提供的Start API来在Raft集群中进行同步的操作</li>
<li>Raft同步到其他的非Leader节点中</li>
<li>Raft层同步成功后，会通过ApplyCh返回信号的KvDatabase</li>
<li>KvDatabase对Client端做出应答（如果成功返回结果为成功，如果下面同步层失败导致超时，返回给客户端的结果为超时）</li>
</ol>

        <h1 id="实验实现"   >
          <a href="#实验实现" class="heading-link"><i class="fas fa-link"></i></a>实验实现</h1>
      <p>此部分实现分为两个部分：</p>
<ol>
<li>基础的键值对的实现</li>
<li>日志压缩与快照的部分</li>
</ol>

        <h2 id="基础键值对的实现"   >
          <a href="#基础键值对的实现" class="heading-link"><i class="fas fa-link"></i></a>基础键值对的实现</h2>
      <p>因为上面提及到这里的KvDatabase 和Raft总体包起来才是一个KVServer的实例，而不是单独脱离的。<br>所以此处展示一下KvRaft所包含的结构</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">type KVServer struct &#123;</span><br><span class="line">	mu      sync.Mutex</span><br><span class="line">	me      int</span><br><span class="line">    &#x2F;&#x2F; 包含了Raft的实例</span><br><span class="line">	rf      *raft.Raft</span><br><span class="line">    &#x2F;&#x2F; Applych 是 用与接受Raft成形成共识后的返回</span><br><span class="line">	applyCh chan raft.ApplyMsg</span><br><span class="line"></span><br><span class="line">	maxraftstate int &#x2F;&#x2F; snapshot if log grows this big</span><br><span class="line">	database map[string]string</span><br><span class="line">	dup map[int64]int</span><br><span class="line">	chanResult map[int]chan Op</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Type OP</span><br><span class="line">type Op struct &#123;</span><br><span class="line">    &#x2F;&#x2F; Key 是 Get()、Put()、Append()三个都会用到的值</span><br><span class="line">	Key      string</span><br><span class="line">    &#x2F;&#x2F; Value是Put()、Append()用到的字段，Get此处默认为空</span><br><span class="line">	Value    string</span><br><span class="line">    &#x2F;&#x2F; 存放的是操作的名称</span><br><span class="line">	Name     string</span><br><span class="line">    &#x2F;&#x2F; 用于表示客户端的来源</span><br><span class="line">	ClientId int64</span><br><span class="line">    &#x2F;&#x2F; 给予序号</span><br><span class="line">	Seq      int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>上面所描述到的Op结构体的操作为什么要把Get加入，并且需要区分ClientId和Seq的原因，本质上都是需要在全序关系广播中实现线性化所需要的。如果不知道什么是全序关系广播，可以查看之前我的文章<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://ray1888.github.io/distributed-system/2019/08/20/distributed-consensus/" >分布式系统一致性与共识</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>此处还需要注意，因为我们暴露给客户端的操作是一个同步的操作，但是我们这层与Raft层是一个异步的操作，因此，需要我们这边等待Raft层异步返回成功，并且我们此层把数据保留下来后，才能继续返回</p>
<p>所以需要需要在另外一个协程中去读取ApplyCH的数据，然后继续对比之后再去创建返回给客户端</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">func (kv *KVServer) ApplyOPRoutine() &#123;</span><br><span class="line">	&#x2F;&#x2F;this gorouine is to asyncly get the result of raft applych reply to</span><br><span class="line">	&#x2F;&#x2F; and to produce signal to reply client Rpc Request</span><br><span class="line">	DPrintf(&quot;Apply gorountine runing &quot;)</span><br><span class="line">	for &#123;</span><br><span class="line">		msg :&#x3D; &lt;-kv.applyCh</span><br><span class="line">		&#x2F;&#x2F;DPrintf(&quot;get apply msg from raftServer&quot;)</span><br><span class="line">		if msg.CommandValid &#123;</span><br><span class="line">			index :&#x3D; msg.CommandIndex</span><br><span class="line">			if cmd, ok :&#x3D; msg.Command.(Op); ok &#123;</span><br><span class="line">				kv.mu.Lock()</span><br><span class="line">                &#x2F;&#x2F; 对比单个客户端的序号，来减少重复的旧操作的更新操作</span><br><span class="line">				if kv.dupcheck(cmd.ClientId, cmd.Seq) &#123;</span><br><span class="line">					if cmd.Name &#x3D;&#x3D; PUT &#123;</span><br><span class="line">						kv.database[cmd.Key] &#x3D; cmd.Value</span><br><span class="line">					&#125; else if cmd.Name &#x3D;&#x3D; APPEND &#123;</span><br><span class="line">						if _, ok :&#x3D; kv.database[cmd.Key]; ok &#123;</span><br><span class="line">							kv.database[cmd.Key] +&#x3D; cmd.Value</span><br><span class="line">						&#125; else &#123;</span><br><span class="line">							kv.database[cmd.Key] &#x3D; cmd.Value</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					kv.dup[cmd.ClientId] &#x3D; cmd.Seq</span><br><span class="line">				&#125;</span><br><span class="line">				res :&#x3D; Op&#123;cmd.Key, kv.database[cmd.Key], cmd.Name,</span><br><span class="line">					cmd.ClientId, cmd.Seq&#125;</span><br><span class="line">				ch, ok :&#x3D; kv.chanResult[index]</span><br><span class="line">				if ok &#123;</span><br><span class="line">					select &#123;</span><br><span class="line">					case &lt;-ch:</span><br><span class="line">					default:</span><br><span class="line">					&#125;</span><br><span class="line">					ch &lt;- res</span><br><span class="line">					&#x2F;&#x2F;DPrintf(&quot;the cmd has been commited , push request return to chan&quot;)</span><br><span class="line">				&#125;</span><br><span class="line">				if kv.maxraftstate !&#x3D; -1 &amp;&amp; kv.rf.GetStateSize() &gt;&#x3D; kv.maxraftstate &amp;&amp; index &#x3D;&#x3D; kv.rf.GetCommitedIndex() &#123;</span><br><span class="line">					DPrintf(&quot;Do snapshot for over the maxraftstate&quot;)</span><br><span class="line">					kv.DoSnapShot(index)</span><br><span class="line">				&#125;</span><br><span class="line">				kv.mu.Unlock()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			kv.LoadSnapShot(msg.Snapshot)</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  把OP传入到Raft共识层的函数</span><br><span class="line">func(rf *Raft) StartCommand(cmd Op) (Err, string)&#123;</span><br><span class="line">    index, _, isLeader :&#x3D; kv.rf.Start(cmd)</span><br><span class="line">	&#x2F;&#x2F;DPrintf(&quot;start command %s , client id is %d, key is %s, value is %s&quot;,</span><br><span class="line">	&#x2F;&#x2F;	cmd.Name, cmd.ClientId, cmd.Key, cmd.Value)</span><br><span class="line">	if !isLeader &#123;</span><br><span class="line">		kv.mu.Unlock()</span><br><span class="line">		&#x2F;&#x2F;DPrintf(&quot;not leader &quot;)</span><br><span class="line">		return ERRWrongLeader, &quot;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	ch :&#x3D; make(chan Op, 1)</span><br><span class="line">	kv.chanResult[index] &#x3D; ch</span><br><span class="line">	kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	defer func() &#123;</span><br><span class="line">		&#x2F;&#x2F; After finish the task</span><br><span class="line">		kv.mu.Lock()</span><br><span class="line">		delete(kv.chanResult, index)</span><br><span class="line">		kv.mu.Unlock()</span><br><span class="line">	&#125;()</span><br><span class="line">	select &#123;</span><br><span class="line">	case c :&#x3D; &lt;-ch:</span><br><span class="line">		&#x2F;&#x2F; this channel return is get data from ApplyRoutine</span><br><span class="line">		if kv.CheckSame(c, cmd) &#123;</span><br><span class="line">			resvalue :&#x3D; &quot;&quot;</span><br><span class="line">			if cmd.Name &#x3D;&#x3D; GET &#123;</span><br><span class="line">				resvalue &#x3D; c.Value</span><br><span class="line">			&#125;</span><br><span class="line">			return OK, resvalue</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			DPrintf(&quot;Leader has change, index %d op %s error&quot;, index, cmd.Name)</span><br><span class="line">			return ERRWrongLeader, &quot;&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	case &lt;-time.After(time.Duration(200) * time.Millisecond):</span><br><span class="line">		DPrintf(&quot;log get agree timeout, index is %d&quot;, index)</span><br><span class="line">		return ERRTimeout, &quot;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="日志压缩与快照"   >
          <a href="#日志压缩与快照" class="heading-link"><i class="fas fa-link"></i></a>日志压缩与快照</h2>
      <p>此处的快照与Raft本身的快照多了两个KVDatabase 特有的属性， database（保存的数据） 和 dup （客户端操作序号的记录）这两个属性</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func (kv *KVServer) DoSnapShot(index int) &#123;</span><br><span class="line">	kv.rf.SaveSnapShot(index, kv.database, kv.dup)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 读取快照的函数</span><br><span class="line">func (kv *KVServer) LoadSnapShot(snapshot []byte) &#123;</span><br><span class="line">	if snapshot &#x3D;&#x3D; nil || len(snapshot) &lt; 1 &#123;</span><br><span class="line">		kv.mu.Lock()</span><br><span class="line">		kv.database &#x3D; make(map[string]string)</span><br><span class="line">		kv.mu.Unlock()</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	s :&#x3D; bytes.NewBuffer(snapshot)</span><br><span class="line">	decoder :&#x3D; labgob.NewDecoder(s)</span><br><span class="line">	var kvdb map[string]string</span><br><span class="line">	var kvdup map[int64]int</span><br><span class="line">	if decoder.Decode(&amp;kvdb) !&#x3D; nil || decoder.Decode(&amp;kvdup) !&#x3D; nil &#123;</span><br><span class="line">		DPrintf(&quot;server %d, Decode Snapshot error&quot;, kv.me)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		kv.mu.Lock()</span><br><span class="line">		defer kv.mu.Unlock()</span><br><span class="line">		kv.database &#x3D; kvdb</span><br><span class="line">		kv.dup &#x3D; kvdup</span><br><span class="line">		DPrintf(&quot;msg snapshot db is %v, dup is %v&quot;, kvdb, kvdup)</span><br><span class="line">		DPrintf(&quot;server %d , load Snapshot success&quot;, kv.me)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>在本实验中，会触发日志保留的情况只是因为保存的Log&gt; maxraftstate。 </p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2019/08/28/distribute-system-consensus/">分布式系统一致性与共识</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-08-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-01-22</span></span></div></header><div class="post-body"><div class="post-excerpt"><!-- ---
title: 
author: Ray Chan(ray1888)
date: '2019-08-20 11:08:38 +0800'
category: 
summary: Distributed System Consistency and Consensus
thumbnail: distributed-system.png
--- -->


        <h1 id="目录"   >
          <a href="#目录" class="heading-link"><i class="fas fa-link"></i></a>目录</h1>
      <ol>
<li><a href="#PromiseAbstraction">分布式系统可以提供的若干保证和抽象机制</a><br>1.1 <a href="#1.1">共识算法的意义</a>  </li>
<li><a href="#atomic">如何在分布式系统中做到原子性</a><br>2.1 <a href="#2.1">可线性化</a><br>2.2 <a href="#2.2">顺序化</a>  <pre><code> 2.2.1 [顺序、因果、全局序号的关系](#2.2.1)  
 2.2.2 [全局关系的广播](#2.2.2)  </code></pre>
</li>
<li><a href="#Capability">分布式系统的能力边界</a><br>3.1  <a href="#3.1">分布式事务</a><br>3.2  <a href="#3.2">容错的共识</a>  </li>
<li><a href="#ShareNote">ShareNote</a>  </li>
</ol>

        <h1 id="分布式系统可以提供的若干保证和抽象机制"   >
          <a href="#分布式系统可以提供的若干保证和抽象机制" class="heading-link"><i class="fas fa-link"></i></a>分布式系统可以提供的若干保证和抽象机制</h1>
      
        <h2 id="共识-分布式一致性-算法的意义"   >
          <a href="#共识-分布式一致性-算法的意义" class="heading-link"><i class="fas fa-link"></i></a>共识(分布式一致性)算法的意义</h2>
      <p>对于大多数的多副本的数据库（N&gt;=2)的情况下，它至少达到了最终的一致性。但是因为只是最终，但是到达最终的状态的时间是未知的。<br>最终一致性的多副本数据状态（如Aurora、Riak、Cassandra）的不一致对于应用开发者是比较棘手，因为很多底层保证一致的东西需要挪动到应用层上面去添加规则来继续保证。并且导致测试和验证都会变得异常的困难</p>
<p>基于上面的问题，我们可能需要找到一个更加强一致性的模型来进行构建，可以把应用层可能遇到的数据库不一致的问题封装起来。虽然可能会付出其他的代价（如性能下降、容错性差）</p>

        <h3 id="与事务隔离的级别的差别"   >
          <a href="#与事务隔离的级别的差别" class="heading-link"><i class="fas fa-link"></i></a>与事务隔离的级别的差别</h3>
      <p>共识与事务隔离都有类似与副本的概念（事务隔离是使用乐观锁（MVCC） 共识是使用多副本）<br>共识：更加强调是针对延时和故障协调副本之间的关系。<br>事务隔离：处理并发事务的各种临界的条件  </p>

        <h1 id="如何在分布式系统中做到原子性"   >
          <a href="#如何在分布式系统中做到原子性" class="heading-link"><i class="fas fa-link"></i></a>如何在分布式系统中做到原子性</h1>
      
        <h2 id="可线性化"   >
          <a href="#可线性化" class="heading-link"><i class="fas fa-link"></i></a>可线性化</h2>
      <p>（此部分主要是DDIA第9章节的内容）<br>定义： 让一个分布式的系统看起来像一个单副本的系统，并且所有的操作都是原子的。  </p>

        <h3 id="一个非线性化的例子"   >
          <a href="#一个非线性化的例子" class="heading-link"><i class="fas fa-link"></i></a>一个非线性化的例子</h3>
      <!-- ![非线性化图片](/assets/img/posts/non-linearized-example.png)   -->
<img src="/2019/08/28/distribute-system-consensus/non-linearized-example.png" class="" title="非线性化">

<p>对于上面这个图的简要描述：<br>因为使用了多节点非强一致性的数据库，当Referee修改数据库的情况下，因为集群内同步的时间不一致，导致可能Alice先查的的Slave-1 已经修改了，但是Bob查询的Slave-2的库上面还没有修改，导致Alice和Bob获取到的结果不一致。这种场景对于一些一致性需求比较强的情况下不能接受。</p>

        <h3 id="线性化的例子的直觉表达"   >
          <a href="#线性化的例子的直觉表达" class="heading-link"><i class="fas fa-link"></i></a>线性化的例子的直觉表达</h3>
      <p><b><font color="#FF0000">线性化的简洁但是事实上的描述： 让分布式系统具有寄存器的语义。</font></b><br>对于这个部分，我们详细去探讨一下<br>一般我们的对于读写请求并发（在客户端的角度）是这样的:<br>定义一个前提， 下图中的一个框是指客户端从发出请求到接收到返回值的整个过程<br>单个框可以理解为 客户端发出请求-&gt; 服务器端接受并且处理请求-&gt; 服务器端返回结果-&gt; 客户端在应用级别收到返回<br>下面可能出现框比较长的情况是在上一篇文章（<img src="https://ray1888.github.io/distributed-system/2019/08/20/chanllange-of-distributed-system/" alt="分布式系统简介以及其问题">）的假设所提及的情况，此处不再复述。  </p>
<p>分布式系统中的寄存器： 线性化数据库中的相同的主键。（此处为X)  </p>
<!-- ![粗粒度线性一致](/assets/img/posts/generate-line.png)   -->
<img src="/2019/08/28/distribute-system-consensus/generate-line.png" class="" title="粗粒度线性一致">
<p>此处对于寄存器有两类的操作：</p>
<ol>
<li>read(x)  读取主键为X的值，数据库返回值v</li>
<li>write(x,v) 客户端把X的值更新为V，数据库返回值为r(成功或者失败)</li>
</ol>
<p>对于上图在read和write重合的过程中，read的结果可能有2种情况：  </p>
<ol>
<li>read在write完成之前结束(返回0)  </li>
<li>read在write完成之后结束 (返回1)  </li>
</ol>
<p>但是这个描述的粒度还是比较大，为了把系统线性化的更好的描述，我们添加下面的约束  </p>
<!-- ![细粒度线性一致](/assets/img/posts/more-detail-line.png)   -->
<img src="/2019/08/28/distribute-system-consensus/more-detail-line.png" class="" title="细粒度线性一致">
<p>约束为，在写操作的过程中，肯定有某一个时间点，存储上面的x的值会出现冲0到1的跳变。<br>对于上图， 客户端A在某个节点能够读到X的值为1，那么因为客户端B的读操作是晚于客户端A读的发生的，因此<br>客户端B获取到的值也必然是1（如果不是1，则不是可线性化的系统）。  </p>
<!-- ![线性一致](/assets/img/posts/line-final.png) -->
<img src="/2019/08/28/distribute-system-consensus/line-final.png" class="" title="线性一致">
<p>但是上面的讨论颗粒还是太大了，此处我们加入进去存储，以及存储接收到的操作来整体观察线性一致。<br>我们此处引入一个概念</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CAS(compare and swap):一个原子的比较设置操作。编程语言中一般都要实现此概念，此处不详细叙述</span><br></pre></td></tr></table></div></figure>
<p>并且添加一个假设：即使客户端可能还没有收到成功的响应，但是分布式的存储已经全部同步成新的值。<br>上图中每个操作都有竖线，表示可能的执行的时间点，把这些点连接起来，最终结果必须是一个有效的寄存器读写顺序。<br>可线性化的要求： 按时间箭头向前移动，不能向后移动。<br>可以看到上图中，最后客户端A的操作在c的Cas操作完成后，x的值已经变成了4，但是如果发现读的值为2的话，按时间线的理解就是错误了。因为根据可线性化的要求，cas操作已经执行了，并且时间只能向前走的情况下，客户端A的读操作必然是需要返回4的。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;可线性化和可串行化的对比</span><br><span class="line">#### 可线性化</span><br><span class="line">对寄存器（单个对象）的最新值保证。他不要求将操作组合到事务中，可能会出现写倾斜的问题（如果不采取手段去解决的问题）</span><br><span class="line">#### 可串行化</span><br><span class="line">是事务的隔离属性。每个事务可以读写多个对象，用于确保事务执行的结果与串行执行相同。即使穿行执行的顺序和实际执行的顺序并不一定相同（可能实际上的执行是并行执行事务，但是对外暴露的结果是一致的就可以）  </span><br></pre></td></tr></table></div></figure>

        <h3 id="需要用到线性化的使用场景"   >
          <a href="#需要用到线性化的使用场景" class="heading-link"><i class="fas fa-link"></i></a>需要用到线性化的使用场景</h3>
      <ol>
<li>加锁与主节点选举<br>对于主从复制系统的选主问题，可以通过基于Etcd或者ZooKeeper来进行抢锁操作控制选主</li>
<li>约束与唯一性保证<br>应用中对同一个资源（如用户名）的唯一性的约束。（可以延展到数据表的主键约束）</li>
<li>多信息源的时间依赖<br>对于一些异步任务系统虽然采用了最终一致性，但是可能也是会因为实现产生数据的依赖问题。</li>
</ol>

        <h3 id="如何实现一个线性化系统"   >
          <a href="#如何实现一个线性化系统" class="heading-link"><i class="fas fa-link"></i></a>如何实现一个线性化系统</h3>
      
        <h4 id="对比多种可能使用的方案来确定"   >
          <a href="#对比多种可能使用的方案来确定" class="heading-link"><i class="fas fa-link"></i></a>对比多种可能使用的方案来确定</h4>
      <p>在考虑容错的基础上，必须考虑复制的机制。我们可以对比多种复制方案来看看那种可以实现线性化</p>
<ol>
<li>主从复制。（部分线性化）<br>因为所有写入操作都是从主节点继续，并且把操作同步到从节点上面。但是问题可能出现在实现的问题上：  <ol>
<li>实时同步可能会出现问题</li>
<li>可能会因为快照隔离设计出现问题</li>
</ol>
</li>
<li>共识算法（可线性化）<br>类似于主从复制，但是通过一些手段来防止脑裂和过期的副本</li>
<li>多主复制（不可线性化）<br>当允许并发写入的时候，如果进行异步复制的话，可能会出现数据的冲突。</li>
<li>无主复制（可能不可线性化）<br>类似于Dynamo的机制，即使使用了Quroum机制，但是如果选取的Quroum不一定是满足的情况下，可能会出现非线性化的处理</li>
</ol>
<p>此处提出一个问题，是否只要有Quroum机制（就必定可以支持线性一致呢？）<br>答： 不一定。用下面的例子进行解释  </p>
<!-- ![QuroumFail](/assets/img/posts/quroum-fail.png)   -->
<img src="/2019/08/28/distribute-system-consensus/quroum-fail.png" class="" title="QuroumFail">

<p>对于上图中，即使是使用了Quroum，但是没有共识算法的支持，还是可能会出现类似于之前Alice和Bob遇到的情况的问题。但是这个选取的直接是一个Quroum，但是是因为缺少共识，并且网络出现问题才会导致这样的情况出现。</p>

        <h3 id="线性化的代价"   >
          <a href="#线性化的代价" class="heading-link"><i class="fas fa-link"></i></a>线性化的代价</h3>
      <p><font color="#FF0000">线性化出现代价的最主要的原因还是因为网络的不确定性。</font></p>
<p>我们先用主从的架构来讨论这个问题，当网络发生分区的情况，主从不能够继续同步操作，可能会导致从库不可用。<br>但是这个是我们需要实现线性化所带来的不可用</p>
<p>先引入一个概念：CAP理论</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CAP : 在同一个时间内，当网络出现分区的情况下，不可能获得兼容可用性和一致性。</span><br></pre></td></tr></table></div></figure>
<p>CAP理论的推理：不要求线性化的应用更能够容忍网络分区。</p>
<p>但是为了线性化，我们可能要牺牲性能和延迟。<br>那么我们是否有方法可以做到线性化但是减少性能的牺牲呢？</p>

        <h2 id="顺序保证"   >
          <a href="#顺序保证" class="heading-link"><i class="fas fa-link"></i></a>顺序保证</h2>
      <p>我们刚刚在讨论线性化的时候使用到了寄存器的概念，那么顺序、可线性化、共识之间是否存在的某种关系呢？</p>

        <h3 id="顺序、因果、全局序号的关系"   >
          <a href="#顺序、因果、全局序号的关系" class="heading-link"><i class="fas fa-link"></i></a>顺序、因果、全局序号的关系</h3>
      
        <h4 id="顺序和因果的关系"   >
          <a href="#顺序和因果的关系" class="heading-link"><i class="fas fa-link"></i></a>顺序和因果的关系</h4>
      <p>因果关系对所发生的事件添加了排序， 一件事情会导致另外一件事情，这些的因果关系依赖链条定义了系统中的因果顺序。如果符合因果关系所规定的顺序，我们称之为因果一致性。（快照隔离，在从数据库中读数据的情况下，查询到的诗句，也可以查到这个数据之前发生了什么的操作事件）</p>

        <h4 id="因果顺序并非全序"   >
          <a href="#因果顺序并非全序" class="heading-link"><i class="fas fa-link"></i></a>因果顺序并非全序</h4>
      <p>全序关系是可以支持两个不同的实体直接进行比较（如自然数集5和13的比较）<br>但是部分集合的对比不一定符合全序，集合{a,b} 与 集合{b,c}是无法进行对比的  </p>
<p>因此，提炼到可线性化和因果关系中<br>可线性化是存在全序的操作关系，因为暴露对外的行为是与单副本无异，并且每个操作都是原子的。可以分出先后<br>因果是偏序的操作关系，对于并发的两个操作无法比较的情况下，就会发生冲突，对于可以比较的情况下，与线性无异。<br>那么可以这样说，可线性化一定意味着因果关系，因为可线性化是全序的操作。<br>但是可以这样理解，线性化并非是保证因果关系的唯一的途径。我们可以有其他手段去满足因果一致性而避免线性化所带来的问题。<br>因果一致性是被认为是不会由于网络延迟而显著影响性能，并且可以对网络故障容错提供容错的最强一致性的模型。<br>因为实际上很多的应用所需要的是因果一致性来保证应用的正确性。  </p>

        <h4 id="捕获因果依赖关系"   >
          <a href="#捕获因果依赖关系" class="heading-link"><i class="fas fa-link"></i></a>捕获因果依赖关系</h4>
      <p>如果只要解决并发操作的先后依赖关系。这里其实只需要由偏序的关系即可。<br>我们常见的数据库的版本技术就是一个解决这个问题的方案之一<br>为了确定数据库的因果关系，数据库需要知道应用读取的是哪个版本的数据。</p>

        <h4 id="序列号排序"   >
          <a href="#序列号排序" class="heading-link"><i class="fas fa-link"></i></a>序列号排序</h4>
      <p>那么，这样的情况下，我们是否需要显式的跟踪所有的因果关系呢？<br>为了性能的考虑，我们可以通过序列号和时间戳（尽量不使用物理时钟）来进行对事件排序，这样在保证性能的同时，也能够保证所有操作在全局的关系。但是要保证每个序列号必须唯一，并且可以比较。<br>我们可以按照与因果关系一致的顺序来创建序列号： 如果操作A发生B之前，那么A一定在全序顺序中出现在B之前<br>这样的全局排序可以捕获所有的因果信息，并且加强了比因果关系更为严格的顺序性  </p>
<p>那么对于不存在唯一的主节点（多主或者无主），那么我们能怎样生成上面所提及的序列号呢？<br>有实践中可以采用以下方法：<br>    1. 每个节点单独生成自己的一组序列号。假设有两个节点，一个生成奇数，一个生成偶数<br>    2. 把Timestamp添加到操作中（之前生产中有用此种方式）<br>    3. 预先分配序列号的区间范围。（A节点分配1-1000，B节点分配1001-2000）  </p>
<p>但是这三种实际上生成的唯一的，近似增加的序列号。但是实际上序列号和因果一致不是完全因果一致的。<br>为什么不是因果一致呢?<br>对于情况1，每个节点处理的速率是由不一致的，只要两个节点处于处理速率不一致的情况下，分配的ID必然和实际的顺序关系无法对应<br>对于情况2， 墙上时钟发生偏移的情况<br>对于情况3， 如果sharding的路由发生了变化之后，那么之前1-1000的因果关系就不存在了。  </p>
<p>那么我们是否没有办法可以在非强主的情况可以获取一个序列号与因果一致可以对应上的吗？  </p>
<p>我们还有一个方法！！！此处大神来了Leslie Lamport的Lamport TimeStamp可以解决这个问题  </p>

        <h4 id="LamportTimeStamp"   >
          <a href="#LamportTimeStamp" class="heading-link"><i class="fas fa-link"></i></a>LamportTimeStamp</h4>
      <!-- ![LamportTimeStamp](/assets/img/posts/LamportTimestamp.png)   -->
<img src="/2019/08/28/distribute-system-consensus/LamportTimestamp.png" class="" title="LamportTimeStamp">
<p>每个节点一开始的时候都会有一个唯一的标识符（每次初始为0）， 然后每个节点都有一个计数器来记录各自处理的请求总数。到此与之前的时间戳的并无差别，但是Lamport这里处理的亮点出来了，每个节点和每个客户端都会跟踪迄今为止最大的计数器值，并且在每个请求中附带该最大计数器值。当节点收到某个请求的时候，如果发现请求内的最大计数器值大于自身的计数器值，会更新自己的计数器值（Raft中是通过投票和心跳的RPC来同步这个计数器的值，在Raft的概念里面叫做Term，后面讲解Raft的时候会进一步解析，此处只是一个插叙）。</p>
<p>LamportTimeStamp好像是解决了分布式系统顺序号和因果一致的关系，但是是已经足够解决分布式系统中常见的问题了吗？<br>问题如下：<br>    一个系统的用户名只能由唯一的用户持有，两个用户并发地向系统同时进行注册，我们必须要保证一个成功，一个失败<br>虽然看上去我们是可以把两个请求通过编号把两个并发的请求变成了一个有顺序的问题，但是实际上要保证上面的是唯一的有两个前提：<br>    1. 节点收到用户请求的时候需要马上判断请求时成功还是失败<br>    2. 必须要收集系统的所有创建用户的请求，比较序号<br>但是这个显然是不可能的，只要网络出现问题了，我们就无法做到上面的两个问题。</p>
<p>那么我们如果要知道全局关系是否确定，就需要提到后面的一个概念，全序关系广播</p>

        <h3 id="全局关系的广播"   >
          <a href="#全局关系的广播" class="heading-link"><i class="fas fa-link"></i></a>全局关系的广播</h3>
      <p>继续先从一个主从复制的系统开始说起，主节点接受写请求并且变成顺序的操作。<br>但是在分布式系统领域，如何扩展系统的吞吐量使之突破单一主节点限制以及处理主节点失效时的故障切换。这类的问题被称为全序关系广播或者原子广播。<br>全序关系广播： 通常指节点之间交换信息的某种协议。有两个特性<br>    1. 可靠发送（没有消息丢失，如果消息发送到某一个节点，它一定要发送到其他的节点）<br>    2. 严格有序（消息总是以相同的顺序发送到每个节点）  </p>

        <h4 id="使用全序关系广播"   >
          <a href="#使用全序关系广播" class="heading-link"><i class="fas fa-link"></i></a>使用全序关系广播</h4>
      <p>Zookeeper和Etcd的共识服务就实现了全序关系广播。（那么全序关系广播和共识之间的关系？）  </p>
<p>全序关系广播就是数据库所需要，每条消息表达数据库的写请求，而且每个副本段相同的顺序处理这些写请求，那么所有副本可以保持一致。这个也被称为状态机复制。  </p>
<p>全局关系广播的另一个要点，顺序在发送消息时已经是确定的，如果消息发送成功，节点不允许追溯将某条消息插到先前的位置上。只能进行追加，这样全序关系广播比时间戳的排序要求更强<br>应用场景：<br>    1.我们可以使用全序关系广播来实现可串行化的事务。（每个消息表示为一个确定性质的事务，并且作为存储过程来执行）<br>    2.提供Fencing令牌锁的服务（把取锁的请求变成一个消息追加到日志中，序列号直接可以变成令牌返回）  </p>

        <h4 id="全序关系广播来实现线性化存储"   >
          <a href="#全序关系广播来实现线性化存储" class="heading-link"><i class="fas fa-link"></i></a>全序关系广播来实现线性化存储</h4>
      <p>全序关系广播是基于异步模型，保证消息以固定顺序的可靠发送，但是不保证消息何时发送成功，但是可线性化更多地强调读取时能看到最新的写入值。<br>我们可以通过追加的日志的方式使得使用全序关系广播在写入的方式上与可线性化做到一致<br>    1. 在接受请求的本地节点中追加一条消息，指明写入的信息<br>    2. 读取日志，广播到其他节点，等待回应<br>    3. 如果回复中有冲突，则失败，返回错误给客户端；否则返回成功给客户端<br>通过日志追加可以把并发有效的转换为多条的日志来保证因果顺序关系。但是读取却还没做到这个语义<br>为了读取可以与可线性化一致，有以下方法可以解决这个问题：<br>    1. 把读的请求也变成日志的方式追加到排序广播，通过变成日志的情况下可以确定了顺序的问题。（ETCD采用的是这种方式）<br>    2. 如果可以以可线性化的方式获取最新日志的消息位置，则查询位置，直到该位置之前的所有条目读发送给你，再进行读取（ZooKeeper使用的方式）<br>    3. 可以从同步更新的副本中进行读取，保证每次读的是最新的值。  </p>
<p>所以最终可线性化的原子地对寄存器做CAS的操作与全序关系广播其实等价于共识的问题。</p>

        <h1 id="分布式共识的能力边界"   >
          <a href="#分布式共识的能力边界" class="heading-link"><i class="fas fa-link"></i></a>分布式共识的能力边界</h1>
      <p>共识： 使得分布式系统中就某件事情达成一致<br>共识的使用场景：<br>    1. 主节点选举（防止脑裂问题）<br>    2. 原子事务的提交（跨节点或分区的数据库，事务在部分节点成功，部分节点失败，需要进行回滚）<br>我们先从事务的原子性开始，讨论2PC（2阶段提交），之后再会谈及其他更好的共识算法的实现（ZooKeeper， Raft）  </p>

        <h2 id="分布式事务"   >
          <a href="#分布式事务" class="heading-link"><i class="fas fa-link"></i></a>分布式事务</h2>
      <p>事务原子性的目的：<br>一个多笔写操作的事务在执行过程中出现意外情况，为上层应用提供一个简单的语义，全部成功或者全部失败<br>单机原子提交：<br>数据库把事务写入持久化部分，然后把提交记录追加写入到磁盘的日志文件中。所以在单节点上面，事务提交非常依赖与数据持久写入磁盘的顺序关系<br>    1. 先写入数据，再提交记录<br>    2. 事务提交或者中止的关键点在于磁盘完成日志的时候，在完成写之前崩溃的情况下，事务需要中止；如果日志在完成写入后发生崩溃，事务被安全提交  </p>
<p>但是对于分布式多节点，处理方法有所差别，原因可能是以下这几个问题引起的<br>    1. 某些节点发现不满足要求中止了事务，但是部分节点通过并且提交<br>    2. 部分请求可能在网络不稳定的情况下丢失，超时而中止；但是其他请求可能成功提交<br>    3. 节点可能在写入日志前崩溃，而且在恢复后回滚（原来数据没有成功，回滚可能会出现问题）<br>如果一部分节点提交了事务，但是部分节点放弃了事务，会导致集群中节点信息的不一致，而且事务一旦被提交，即使事后发现其他节点中止，也无法撤销本节点的事务  </p>
<p>事务提交后不能撤销的原因：<br>一旦数据提交，就会被其他事务可见，然后客户端（应用层）就会做出相应的反应，这个是构成读-提交隔离的基础。但是如果允许撤销的话，那么所有之后的读-提交级别的任务，然后会产生多级的级联式追溯和撤销。导致系统压力巨大甚至崩溃。并且不能保证数据是否能够准确落盘。  </p>
<p>因为不允许撤销事务，因为如果一个错误的事务被提交了，必然需要一个新的事务来抵消它的影响，但是这个需要应用层来进行处理，就不符合我们需要给应用层提供的原子性。  </p>

        <h3 id="2PC"   >
          <a href="#2PC" class="heading-link"><i class="fas fa-link"></i></a>2PC</h3>
      <p>两阶段提交（2PC）是一种在多个节点上实现事务原子提交的算法。要么全部提交，要么全部不提交。</p>

        <h5 id="2PC的流程（为什么可以解决上面单阶段提交的问题）"   >
          <a href="#2PC的流程（为什么可以解决上面单阶段提交的问题）" class="heading-link"><i class="fas fa-link"></i></a>2PC的流程（为什么可以解决上面单阶段提交的问题）</h5>
      <ol>
<li>应用启动分布式事务的时候，先去像协调者获取事务ID（全局唯一）</li>
<li>应用程序在每个参与的节点启动单节点事务，并且把事务ID附加到到参与者的事务上。如果这个阶段发生异常，可以协调者和其他参与者可以安全中止</li>
<li>应用程序准备提交事务时，协调者回向参与者发送携带事务ID准备请求，只要有一个发现失败的情况下，通知全部放弃事务</li>
<li>参与者收到请求后，确保自己时候可以提交事务（包括硬件故障和软件故障的确认），然后检查是否有冲突或者违规。一旦返回是，节点会承诺提交事务。（保证了参与者不会撤销事务）</li>
<li>当协调者收到所有的参与者返回后，要决定是否提交事务，并且把此决定写入到硬盘的事务日志（WAL）中，防止掉电后可能出现的异常</li>
<li>协调者向参与者发送提交/放弃 事物的请求，只要是提交，每个参与者会重试到成功为止(包括了进程崩溃的重试、节点重启等情况)</li>
</ol>
<p>所以他是在保证了上面的一个重要前提，只要提交了就不能撤回。<br>在参与者在返回给协调者的时候保证了单向性<br>并且协调者确定提交了之后也是保证了不可逆，因此保证了2pc可以不会出现那些异常的情况。</p>
<p>但是2PC的单点在于协调者的问题（虽然可以采用共识层来写协调者保证高可用）但是整个过程中的热点也会出现在协调者上面。</p>

        <h3 id="实际生产上面的分布式事务"   >
          <a href="#实际生产上面的分布式事务" class="heading-link"><i class="fas fa-link"></i></a>实际生产上面的分布式事务</h3>
      
        <h3 id="异构分布式事务"   >
          <a href="#异构分布式事务" class="heading-link"><i class="fas fa-link"></i></a>异构分布式事务</h3>
      <p>虽然分布式事务因为这样可能会有阻塞而导致性能和吞吐量的下降，但是是否没有折中的方法来使用类似的语义呢？<br>目前更多的是采用了异构的方法（如数据库+MQ）的执行异构的分布式事务</p>
<p>对于异构形式的分布式事务，当且仅当数据库中处理消息的事务成功提交，消息队列才会标记该消息处理完毕。<br>但只要其中一个出现失败的情况，两个部分都必须进行中止的操作。</p>
<p><b>保证消息可以有效处理有且仅有一次</b></p>
<p>目前有XA的异构的分布式事务的标准。</p>

        <h2 id="支持容错的共识"   >
          <a href="#支持容错的共识" class="heading-link"><i class="fas fa-link"></i></a>支持容错的共识</h2>
      <p>共识问题的形式化描述： 一个或者多个节点可以提议某些值，由共识算法来决定最终的值。</p>
<p>基于上面的描述共识算法必须满足以下的性质：<br>    1. 协商一致性（所有节点都接受相同的决议）<br>    2. 诚实性（所有节点不能反悔，对某项提议不能有两次决定）<br>    3. 合法性（决定了值V, 那么V肯定是由某个节点提议的）<br>    4. 可终止性（如果节点不崩溃最终一定可以达成协议）</p>
<p>协商一致性和诚实的属性定义了共识算法的核心思想：决定一致的结果，并且一旦决定就不能改变。<br>合法性是为了排除一些无意义的方案，<br>可终止性是容错的体现，避免了整个系统的空转<br>根据之前提及的： 可终止性是活性， 其他三个是安全方面的属性。</p>
<p>因为共识算法的目的是解决在大多数节点正常的情况下正确运行才能确保终止性。</p>

        <h3 id="共识算法和全序广播的关系"   >
          <a href="#共识算法和全序广播的关系" class="heading-link"><i class="fas fa-link"></i></a>共识算法和全序广播的关系</h3>
      <p>共识算法(如Raft、Paxos、Zab)等都不是直接采用上述的形式化模型。而是决定了一系列的值，然后采用全序关系广播算法来进行实现。  </p>
<p>全序关系广播要点： 消息按相同的顺序发送到所有的节点，有且只有一次。<br>这样的方式相当于多轮的共识过程。在每一轮，节点会提出之后需要发出的信息，然后决定下一个顺序。</p>
<p>对于上面的提到的四个性质：</p>
<ol>
<li>由于协商的一致性，所有节点决定以相同的顺序发送相同的消息。</li>
<li>由于诚实性，消息不会重复</li>
<li>由于合法性， 消息不会被破坏，也不是凭空捏造</li>
<li>由于可终止性，消息不会丢失</li>
</ol>

        <h3 id="Epoch-和-Quorum"   >
          <a href="#Epoch-和-Quorum" class="heading-link"><i class="fas fa-link"></i></a>Epoch 和 Quorum</h3>
      <p>对于共识算法来说，都采用了一个弱化的保证，定义了一个世代编号（Epoch）来确保每个世代里面，主节点是唯一的。<br>如果发现当前主节点失效的情况，节点开始选举新一轮的主节点，Epoch号递增。在主节点做出任何决定的时候，都需要检查是否由比它更高的Epoch号码。<br>主节点必须从Quorum中收集投票，并且把提议传送到各个节点中，等待节点的返回，当只要没有更高的Epoch主节点<br>时，才会对当前的提议进行投票。</p>
<p>此处其实是由两个操作组成：1. 选举主节点； 2.对主节点的提议进行投票</p>
<p>注意的一点： 参与两轮的Quorum必须要由重合，这样才能保证主节点没有更高的Epoch，保证正确性。</p>
<p>与2PC的差别， 2PC是需要协调者向每个参与者做出“是”的返回才能进行，而共识算法可以通过直接以集群的多数来确定是否通过决议</p>

        <h3 id="共识算法的局限性"   >
          <a href="#共识算法的局限性" class="heading-link"><i class="fas fa-link"></i></a>共识算法的局限性</h3>
      <p>共识算法虽然为分布式系统带来了好处，为一切不确定的系统带来了安全属性和容错性。并且可以通过全序关系广播以容错的方式实现线性化的原子操作。</p>
<p>但是共识也是有代价的：</p>
<ol>
<li>节点投票是一个同步复制过程，性能可能需要妥协（但是可以通过减少选举的频率来减少整个开销）</li>
<li>共识体系需要严格的多数节点才能执行，换句话来说，最少需要3个节点才能运行</li>
<li>多数的共识算法假定了一组固定的参与投票的节点集（主要是为了理解的方便）</li>
<li>共识算法需要依靠超时来对节点失败进行检测，但是可能会出现因为网络原因的误判导致经常切主，数据搬移多，对外的性能降低。</li>
<li>网络的影响较大，如果出现频繁切主的情况，可能会有长时间出现无法正常对外进行服务</li>
</ol>

        <h3 id="基于共识算法的成员与协调服务"   >
          <a href="#基于共识算法的成员与协调服务" class="heading-link"><i class="fas fa-link"></i></a>基于共识算法的成员与协调服务</h3>
      <p>对于像ZooKeeper、Etcd这些分布式键值对的服务，暴露的API与数据库是十分类似的，但是为什么我们需要在共识层上面去构建这些服务呢？</p>

        <h4 id="作用"   >
          <a href="#作用" class="heading-link"><i class="fas fa-link"></i></a>作用</h4>
      <p>这些分布式键值对数据库主要是针对保存少量，可完全载入内存的数据。采用容错的全序广播算法在所有节点上复制数据使得可以实现高可用的目标。</p>
<ol>
<li>线性化的原子操作<br>多个节点同时去获取锁，只有一个会成功，共识协议会保证操作满足原子性和线性化，即使节点出现部分失败的情况</li>
<li>操作全序<br>之前分布式系统问题的文章有提及过Fencing令牌的问题，</li>
<li>故障检测<br>客户端会与这些服务保持一个长连接，如果长时间重连失败的情况下，会把该客户端拥有的资源全部释放</li>
<li>更改通知<br>客户端可以通过读取服务来发现其他的客户端的行为</li>
</ol>

        <h4 id="对外的功能"   >
          <a href="#对外的功能" class="heading-link"><i class="fas fa-link"></i></a>对外的功能</h4>
      <ol>
<li>节点任务分配<br>计算作业调度系统(Yarn)，分区资源调度（如Multi-Raft中的ShardMaster)</li>
<li>服务发现<br>解决云环境中服务启停而注册到的服务变更(consul提供的服务)</li>
<li>成员服务<br>节点是否可用并且获取主节点</li>
</ol>

        <h3 id="如何验证一个线性化系统"   >
          <a href="#如何验证一个线性化系统" class="heading-link"><i class="fas fa-link"></i></a>如何验证一个线性化系统</h3>
      <p>（此部分会结合Mit6.824和PingCap tikv 的线性化验证的代码阅读和文章来描述）</p>

        <h1 id="ShareNote"   >
          <a href="#ShareNote" class="heading-link"><i class="fas fa-link"></i></a>ShareNote</h1>
      <ol>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/dynamo.pdf" >Dynamo</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/basho/riak_core" >Riak</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://cassandra.apache.org/" >Cassandra</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://book.douban.com/subject/30329536/" >数据密集型应用系统设计</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/header.jpeg" alt="avatar"></div><p class="sidebar-ov-author__text">Believe in Goods in People</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">13</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">5</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Ray Chen</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.1"></script><script src="/js/stun-boot.js?v=2.6.1"></script><script src="/js/scroll.js?v=2.6.1"></script><script src="/js/header.js?v=2.6.1"></script><script src="/js/sidebar.js?v=2.6.1"></script></body></html>