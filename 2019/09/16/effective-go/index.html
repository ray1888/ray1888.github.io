<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.1" type="image/png" sizes="32x32"><meta name="description" content="本文章的目的是为了详细阅读和理解Effective GO所提及到的内容。                     目录        Method1.1 Pointers vs Values   Data2.1 New vs Make2.2 Array2.3 Slice2.4 Map2.5 Append   Interface Error PackageInit   Defer ShareN">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective Go Reading">
<meta property="og:url" content="http://example.com/2019/09/16/effective-go/index.html">
<meta property="og:site_name" content="Ray 的藏书阁">
<meta property="og:description" content="本文章的目的是为了详细阅读和理解Effective GO所提及到的内容。                     目录        Method1.1 Pointers vs Values   Data2.1 New vs Make2.2 Array2.3 Slice2.4 Map2.5 Append   Interface Error PackageInit   Defer ShareN">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-09-16T03:07:38.000Z">
<meta property="article:modified_time" content="2021-01-22T06:37:38.165Z">
<meta property="article:author" content="Ray Chen">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary"><title>Effective Go Reading | Ray 的藏书阁</title><link ref="canonical" href="http://example.com/2019/09/16/effective-go/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Ray 的藏书阁</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">Effective Go Reading</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-09-16</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-01-22</span></span></div></header><div class="post-body"><!-- --- -->
<!-- layout: post
title: Effective Go Reading
author: Ray Chan(ray1888)
date: '2019-09-16 11:07:38 +0800'
category: go
summary: Effective Go 
thumbnail: go.png
--- -->

<p>本文章的目的是为了详细阅读和理解Effective GO所提及到的内容。</p>

        <h1 id="目录"   >
          <a href="#目录" class="heading-link"><i class="fas fa-link"></i></a>目录</h1>
      <ol>
<li><a href="#Method">Method</a><br>1.1 <a href="#PvV">Pointers vs Values</a>  </li>
<li><a href="#Data">Data</a><br>2.1 <a href="#NewMake">New vs Make</a><br>2.2 <a href="#Array">Array</a><br>2.3 <a href="#Slice">Slice</a><br>2.4 <a href="#Map">Map</a><br>2.5 <a href="#Append">Append</a>  </li>
<li><a href="#InterFace">Interface</a></li>
<li><a href="#Error">Error</a></li>
<li><a href="#Init">PackageInit</a>  </li>
<li><a href="#Defer">Defer</a></li>
<li><a href="#ShareNote">ShareNote</a></li>
</ol>

        <h1 id="Method"   >
          <a href="#Method" class="heading-link"><i class="fas fa-link"></i></a>Method</h1>
      
        <h2 id="Pointers-vs-Values"   >
          <a href="#Pointers-vs-Values" class="heading-link"><i class="fas fa-link"></i></a>Pointers vs Values</h2>
      <p>主要的区别，如果方法是放在类型值上面而不是指针上面的，可以通过指针和普通类型来进行使用。但是对于方法绑定的是指针的类型，只能通过指针来进行使用。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type ByteSlice []byte</span><br><span class="line"></span><br><span class="line">func (slice ByteSlice) Append(data []byte) []byte &#123;</span><br><span class="line">	&#x2F;&#x2F; Body exactly the same as the Append function defined above.</span><br><span class="line">	l :&#x3D; len(slice)</span><br><span class="line">	if l+len(data) &gt; cap(slice) &#123; &#x2F;&#x2F; reallocate</span><br><span class="line">		&#x2F;&#x2F; Allocate double what&#39;s needed, for future growth.</span><br><span class="line">		newSlice :&#x3D; make([]byte, (l+len(data))*2)</span><br><span class="line">		&#x2F;&#x2F; The copy function is predeclared and works for any slice type.</span><br><span class="line">		copy(newSlice, slice)</span><br><span class="line">		slice &#x3D; newSlice</span><br><span class="line">	&#125;</span><br><span class="line">	slice &#x3D; slice[0 : l+len(data)]</span><br><span class="line">	copy(slice[l:], data)</span><br><span class="line">	return slice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *ByteSlice) Append2(data []byte) &#123;</span><br><span class="line">	slice :&#x3D; *p</span><br><span class="line">	&#x2F;&#x2F; Body as above, without the return.</span><br><span class="line">	l :&#x3D; len(slice)</span><br><span class="line">	if l+len(data) &gt; cap(slice) &#123; &#x2F;&#x2F; reallocate</span><br><span class="line">		&#x2F;&#x2F; Allocate double what&#39;s needed, for future growth.</span><br><span class="line">		newSlice :&#x3D; make([]byte, (l+len(data))*2)</span><br><span class="line">		&#x2F;&#x2F; The copy function is predeclared and works for any slice type.</span><br><span class="line">		copy(newSlice, slice)</span><br><span class="line">		slice &#x3D; newSlice</span><br><span class="line">	&#125;</span><br><span class="line">	slice &#x3D; slice[0 : l+len(data)]</span><br><span class="line">	copy(slice[l:], data)</span><br><span class="line">	*p &#x3D; slice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *ByteSlice) Write(data []byte) (n int, err error) &#123;</span><br><span class="line">	slice :&#x3D; *p</span><br><span class="line">	&#x2F;&#x2F; Body as above, without the return.</span><br><span class="line">	l :&#x3D; len(slice)</span><br><span class="line">	if l+len(data) &gt; cap(slice) &#123; &#x2F;&#x2F; reallocate</span><br><span class="line">		&#x2F;&#x2F; Allocate double what&#39;s needed, for future growth.</span><br><span class="line">		newSlice :&#x3D; make([]byte, (l+len(data))*2)</span><br><span class="line">		&#x2F;&#x2F; The copy function is predeclared and works for any slice type.</span><br><span class="line">		copy(newSlice, slice)</span><br><span class="line">		slice &#x3D; newSlice</span><br><span class="line">	&#125;</span><br><span class="line">	slice &#x3D; slice[0 : l+len(data)]</span><br><span class="line">	copy(slice[l:], data)</span><br><span class="line">	*p &#x3D; slice</span><br><span class="line">	*p &#x3D; slice</span><br><span class="line">	return len(data), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var b ByteSlice</span><br><span class="line">	b &#x3D; b.Append([]byte&#123;1, 2, 3&#125;)</span><br><span class="line">	fmt.Printf(&quot;byteSlice 1 is %v&quot;, b)</span><br><span class="line">	b.Write([]byte&#123;7, 8, 9&#125;)</span><br><span class="line">	fmt.Printf(&quot;byteSlice 2 is %v&quot;, b)</span><br><span class="line">    &#x2F;*</span><br><span class="line">    func Fprintf(w io.Writer, format string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">    *&#x2F;</span><br><span class="line">	fmt.Fprintf(&amp;b, &quot;This hour has %d days\n&quot;, 7)</span><br><span class="line">    &#x2F;*</span><br><span class="line">    if use below code , will throw error </span><br><span class="line">    fmt.Fprintf(b, &quot;This hour has %d days\n&quot;, 7)</span><br><span class="line">    *&#x2F;</span><br><span class="line">	b.Append2([]byte&#123;4, 5, 6&#125;)</span><br><span class="line">	fmt.Printf(&quot;byteSlice 3 is %v&quot;, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>上面的例子表达的是，假如直接像注释的代码那样，把B传入一个满足io.Writer的指针的方法中（含有Write方法），但是因为我们的自定义类型上面的Write是指针方法，而不是类型方法，所以会出现类型报错的问题。报错如下</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">as type io.Writer in argument to fmt.Fprintf:</span><br><span class="line">	ByteSlice does not implement io.Writer (Write method has pointer receiver)</span><br></pre></td></tr></table></div></figure>
<p>根据官方的描述，原文如下：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers.</span><br><span class="line"></span><br><span class="line">This rule arises because pointer methods can modify the receiver; invoking them on a value would cause the method to receive a copy of the value, so any modifications would be discarded. The language therefore disallows this mistake. There is a handy exception, though. When the value is addressable, the language takes care of the common case of invoking a pointer method on a value by inserting the address operator automatically. In our example, the variable b is addressable, so we can call its Write method with just b.Write. The compiler will rewrite that to (&amp;b).Write for us.</span><br></pre></td></tr></table></div></figure>
<p>翻译一下：<br>对于接收者类型是指针还是值的规则，值接收者可以 被值或者指针进行调用。而指针方法只能被指针进行调用。</p>
<p>这个规则的产生的原因是因为指针方法可以修改接受者的值。 但是以值的方式继续调用的情况下，go是会自动把值复制一份，然后继续方法的调用，所有对于里面变量得修改都会被丢弃（因为是值传递，除非使用Return +调用的地方有返回值接收）。 因此语言不允许有这种的错误出现。当值是可以获得地址的情况下，语言会自动把值获取指针传入指针调用的方法里面。 </p>

        <h1 id="Data"   >
          <a href="#Data" class="heading-link"><i class="fas fa-link"></i></a>Data</h1>
      
        <h2 id="New-vs-Make"   >
          <a href="#New-vs-Make" class="heading-link"><i class="fas fa-link"></i></a>New vs Make</h2>
      
        <h3 id="New"   >
          <a href="#New" class="heading-link"><i class="fas fa-link"></i></a>New</h3>
      <p>New 是 Go里面的分配内存的方法，但是它只会创建一个Zero值（即创建一个0的空间给对应的内存，并且返回这个变量所占有的内存地址）。</p>
<p>由于由new出来的内存占用为0。这样对于设计你自己的数据结构很有帮助，原因是因为可以默认初始化了0的值，而不用之后再去进行二次的初始化。</p>
<p>官网上的例子：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">For example, the documentation for bytes.Buffer states that &quot;the zero value for Buffer is an empty buffer ready to use.&quot; Similarly, sync.Mutex does not have an explicit constructor or Init method. Instead, the zero value for a sync.Mutex is defined to be an unlocked mutex.</span><br><span class="line"></span><br><span class="line">The zero-value-is-useful property works transitively. Consider this type declaration.</span><br><span class="line"></span><br><span class="line">type SyncedBuffer struct &#123;</span><br><span class="line">    lock    sync.Mutex</span><br><span class="line">    buffer  bytes.Buffer</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>但是有些时候直接初始化0值不要足够，需要一个构建者。像这个例子一样</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func NewFile(fd int, name string) *File &#123;</span><br><span class="line">    if fd &lt; 0 &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    f :&#x3D; new(File)</span><br><span class="line">    f.fd &#x3D; fd</span><br><span class="line">    f.name &#x3D; name</span><br><span class="line">    f.dirinfo &#x3D; nil</span><br><span class="line">    f.nepipe &#x3D; 0</span><br><span class="line">    return f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>因为上面这段代码有比较多的参数，因此我们可以用一个命名的字段来继续初始化</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func NewFile(fd int, name string) *File &#123;</span><br><span class="line">    if fd &lt; 0 &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    f :&#x3D; File&#123;fd, name, nil, 0&#125;</span><br><span class="line">    return &amp;f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>事实上，直接获取复合文字初始化的结构体的地址，实际上会创建一个全新的实例并且赋值，因此我们可以把上面的最后两行代码合成一行代码  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f :&#x3D; File&#123;fd, name, nil, 0&#125;</span><br><span class="line">    return &amp;f</span><br><span class="line">&#x3D;&#x3D;&#x3D; </span><br><span class="line"></span><br><span class="line">return &amp;File&#123;fd, name, nil, 0&#125;</span><br></pre></td></tr></table></div></figure>
<p>用于和范围： 适用于创建数组、切片、映射（with the field labels being indices or map keys as appropriate）。</p>
<p>返回值：<br>一个对应类型的指针</p>

        <h3 id="Make"   >
          <a href="#Make" class="heading-link"><i class="fas fa-link"></i></a>Make</h3>
      <p>Make 可以用于创建并且返回一个非nil的值。<br>适用范围：<br>切片、映射、channel  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make([]int,10,100)  &#x2F;&#x2F; 这样是创建了一个容量为100，但是填入了10个0的切片。</span><br></pre></td></tr></table></div></figure>
<p>官网上面对make的描述</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">For slices, maps, and channels, make initializes the internal data structure and prepares the value for use.</span><br></pre></td></tr></table></div></figure>
<p>返回值：<br>一个对应类型的数据</p>

        <h3 id="Diff"   >
          <a href="#Diff" class="heading-link"><i class="fas fa-link"></i></a>Diff</h3>
      <p>区别上面的Make和New的目的是为了，对于切片、映射、channel这三种类型，在底层的实现原理中都必须要先创建一个底层的实现才能被引用到，才能在暴露给语言的使用者上面不会抛出错误。<br>所以本质上，new创建出来的可以理解为一个nil的对象，而make创建出来的是一个带有底层数据结构，并且有非nil的对象。<br>而且返回值有所不同。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">	 &#x2F;&#x2F; allocates slice structure; *p &#x3D;&#x3D; nil; rarely useful</span><br><span class="line">	var p *[]int &#x3D; new([]int)     </span><br><span class="line">	&#x2F;&#x2F; the slice v now refers to a new array of 100 ints </span><br><span class="line">	var v []int &#x3D; make([]int, 5) </span><br><span class="line">	fmt.Printf(&quot;p values is %v，%v\n&quot;, p, *p&#x3D;&#x3D;nil)</span><br><span class="line">	fmt.Printf(&quot;v values is %v, %v\n&quot;, v, v&#x3D;&#x3D;nil)</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line">p values is &amp;[]，true</span><br><span class="line">v values is [0 0 0 0 0], false</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h2 id="Array"   >
          <a href="#Array" class="heading-link"><i class="fas fa-link"></i></a>Array</h2>
      <p>数组在Go的三个特点：</p>
<ol>
<li>如果直接把数据传入到一个函数中，则是把这个数组的值拷贝一份，然后把拷贝的副本传到函数中进行使用。</li>
<li>数组的长度也是它的类型属性之一，[10]int和[20]int不是等价的。</li>
<li>Array都是值。</li>
</ol>
<p>而且有一个使用的小技巧，如果想要减少传递的数据的量，可以直接传入指针，这样可以免于拷贝多一份中间的数据。<br>对于Go来说，因为数组类型支持的方法比较少，而且不能够通过动态去进行特定长度数组创建。因此更加建议的是用Slice来代替数组。  </p>

        <h2 id="Slice"   >
          <a href="#Slice" class="heading-link"><i class="fas fa-link"></i></a>Slice</h2>
      <p>可以看我的博客另外一篇的文章Go Slice上面有提及高级的用法，此处不再重复。  </p>

        <h3 id="二维数组和二维切片"   >
          <a href="#二维数组和二维切片" class="heading-link"><i class="fas fa-link"></i></a>二维数组和二维切片</h3>
      <p>对于二维数组的声明，可以使用这样的方法  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Transform [3][3]float64  &#x2F;&#x2F; A 3x3 array, really an array of arrays.</span><br><span class="line">type LinesOfText [][]byte     &#x2F;&#x2F; A slice of byte slices.</span><br><span class="line"></span><br><span class="line">text :&#x3D; LinesOfText&#123;</span><br><span class="line">	[]byte(&quot;Now is the time&quot;),</span><br><span class="line">	[]byte(&quot;for all good gophers&quot;),</span><br><span class="line">	[]byte(&quot;to bring some fun to the party.&quot;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如果使用Make来继续初始化的情况。需要考虑两个不同的使用场景导致的初始化方式的不同。<br>第一种：如果内部的一位数组可能发生扩展或者收缩，那么就要单独去分配这个一位数组。<br>第二种： 如果内部的数组长度不会发生size变化而只会发生值得变化，则可以进行统一得初始化。(这样性能会比较好，因为可以一次性的调用Allocate的系统函数，减少分配内存的开销)</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; First Method</span><br><span class="line">picture :&#x3D; make([][]uint8, YSize)</span><br><span class="line">for i:&#x3D; range picture&#123;</span><br><span class="line">    picture[i] &#x3D; make([]uint8, XSize)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Second Method </span><br><span class="line">picture :&#x3D; make([][]uint8, YSize)</span><br><span class="line">pixels :&#x3D; make([]uint8, XSize * YSize)</span><br><span class="line"></span><br><span class="line">for i :&#x3D; range picture&#123;</span><br><span class="line">    picture[i], pixels &#x3D; pixels[:XSize], pixels[XSize:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h2 id="Map"   >
          <a href="#Map" class="heading-link"><i class="fas fa-link"></i></a>Map</h2>
      <p>主要注意当一个Key不存在与一个Map中的情况下，需要使用这种方法来进行判断</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var tz map[string]int</span><br><span class="line">var ds string &#x3D; &quot;abc&quot;</span><br><span class="line">if val, ok :&#x3D; tz[ds]; ok&#123;</span><br><span class="line">    return val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>同理在上面的例子上面，如果反过来进行使用，可以用于判断Key是否存在于Map中。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var tz map[string]int</span><br><span class="line">var ds string &#x3D; &quot;abc&quot;</span><br><span class="line">_, exist :&#x3D; tz[ds]</span><br><span class="line">if !exist &#123;</span><br><span class="line">    return &quot;is not exist&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如果需要删除一个值的情况下,使用delete的函数进行处理</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var tz map[string]int</span><br><span class="line">var ds string &#x3D; &quot;abc&quot;</span><br><span class="line">&#x2F;&#x2F; delete(map, key)</span><br><span class="line">delete(tz, ds)</span><br></pre></td></tr></table></div></figure>

        <h2 id="Append"   >
          <a href="#Append" class="heading-link"><i class="fas fa-link"></i></a>Append</h2>
      <p>Append 可以接受多个参数</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func append(slice []T, elements ...T) []T</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; use case </span><br><span class="line">x :&#x3D; []int&#123;1,2,3&#125;</span><br><span class="line">x &#x3D; append(x, 4, 5, 6)</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></div></figure>
<p>对于如果要把两个数组直接接起来的情况下</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x :&#x3D; []int&#123;1,2,3&#125;</span><br><span class="line">y :&#x3D; []int&#123;4,5,6&#125;</span><br><span class="line">x &#x3D; append(x, y...)</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></div></figure>

        <h1 id="InterFace"   >
          <a href="#InterFace" class="heading-link"><i class="fas fa-link"></i></a>InterFace</h1>
      
        <h2 id="Interface"   >
          <a href="#Interface" class="heading-link"><i class="fas fa-link"></i></a>Interface</h2>
      <p>一个结构体可以实现多个接口，只要它实现了那些接口所定义的方法。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">type Sequence []int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Methods required by sort.Interface.</span><br><span class="line">func (s Sequence) Len() int &#123;</span><br><span class="line">    return len(s)</span><br><span class="line">&#125;</span><br><span class="line">func (s Sequence) Less(i, j int) bool &#123;</span><br><span class="line">    return s[i] &lt; s[j]</span><br><span class="line">&#125;</span><br><span class="line">func (s Sequence) Swap(i, j int) &#123;</span><br><span class="line">    s[i], s[j] &#x3D; s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Copy returns a copy of the Sequence.</span><br><span class="line">func (s Sequence) Copy() Sequence &#123;</span><br><span class="line">    copy :&#x3D; make(Sequence, 0, len(s))</span><br><span class="line">    return append(copy, s...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Method for printing - sorts the elements before printing.</span><br><span class="line">func (s Sequence) String() string &#123;</span><br><span class="line">    s &#x3D; s.Copy() &#x2F;&#x2F; Make a copy; don&#39;t overwrite argument.</span><br><span class="line">    sort.Sort(s)</span><br><span class="line">    str :&#x3D; &quot;[&quot;</span><br><span class="line">    for i, elem :&#x3D; range s &#123; &#x2F;&#x2F; Loop is O(N²); will fix that in next example.</span><br><span class="line">        if i &gt; 0 &#123;</span><br><span class="line">            str +&#x3D; &quot; &quot;</span><br><span class="line">        &#125;</span><br><span class="line">        str +&#x3D; fmt.Sprint(elem)</span><br><span class="line">    &#125;</span><br><span class="line">    return str + &quot;]&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="Coversions"   >
          <a href="#Coversions" class="heading-link"><i class="fas fa-link"></i></a>Coversions</h2>
      <p>上面所引用的到方法其实是重新实现了fmt包里面的Sprint方法。我们可以用一些方法来为这个提速，在调用Sprint之前把数据转换成[]int类型，因为Sequence的本质上就<br>是[]int。  </p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改前</span><br><span class="line">func (s Sequence) String() string &#123;</span><br><span class="line">    s &#x3D; s.Copy()</span><br><span class="line">    sort.Sort(s)</span><br><span class="line">    return fmt.Sprint([]int(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改后</span><br><span class="line">type Sequence []int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Method for printing - sorts the elements before printing</span><br><span class="line">func (s Sequence) String() string &#123;</span><br><span class="line">    s &#x3D; s.Copy()</span><br><span class="line">    sort.IntSlice(s).Sort()</span><br><span class="line">    return fmt.Sprint([]int(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="type-assertions"   >
          <a href="#type-assertions" class="heading-link"><i class="fas fa-link"></i></a>type assertions</h2>
      <p>使用Type switch 实际上的操作会把那个变量根据分支的判断的类型来转型。<br>下面这段代码是一个例子，目的是如果不是string类型, 调用其String()进行输出。而如果是，直接输出。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Stringer interface &#123;</span><br><span class="line">    String() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var value interface&#123;&#125; &#x2F;&#x2F; Value provided by caller.</span><br><span class="line">switch str :&#x3D; value.(type) &#123;</span><br><span class="line">case string:</span><br><span class="line">    return str</span><br><span class="line">case Stringer:</span><br><span class="line">    return str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如果对于使用场景是单分支，只需要判断接口是否为那个类型的实现的情况下，可以使用</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; </span><br><span class="line">str, ok :&#x3D; value.(string)</span><br></pre></td></tr></table></div></figure>
<p>注意的是继续类型推断的情况下，必须要填入实际的类型，不能再填入Interface。</p>

        <h2 id="Generality"   >
          <a href="#Generality" class="heading-link"><i class="fas fa-link"></i></a>Generality</h2>
      <p>如果包里面的一个类型只是为了实现接口并且其他方法不需要进行导出给外部使用的情况下。只需要导出接口就好，这样可以避免对于使用者不感兴趣的方法的实现的复杂度。<br>如官方的Hash模块，crc32.NewIEEE 和 adler32.New这两个方法都是返回 接口类型Hash.Hash32。</p>

        <h2 id="interface-amp-method"   >
          <a href="#interface-amp-method" class="heading-link"><i class="fas fa-link"></i></a>interface &amp; method</h2>
      <p>只要这个类型实现了这个接口的所有方法，即可以把这个类型传入来当接口使用.可以理解为简单的依赖翻转。</p>

        <h1 id="Error"   >
          <a href="#Error" class="heading-link"><i class="fas fa-link"></i></a>Error</h1>
      
        <h2 id="Defination"   >
          <a href="#Defination" class="heading-link"><i class="fas fa-link"></i></a>Defination</h2>
      <p>Error 接口在代码里面的定义是这样的。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">    Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如果需要实现一个自定义的Error（添加部分与业务相关的信息）</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; PathError records an error and the operation and</span><br><span class="line">&#x2F;&#x2F; file path that caused it.</span><br><span class="line">type PathError struct &#123;</span><br><span class="line">    Op string    &#x2F;&#x2F; &quot;open&quot;, &quot;unlink&quot;, etc.</span><br><span class="line">    Path string  &#x2F;&#x2F; The associated file.</span><br><span class="line">    Err error    &#x2F;&#x2F; Returned by the system call.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *PathError) Error() string &#123;</span><br><span class="line">    return e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>并且建议的可行方法，错误信息应该能够表明他们的来源（即发生错误的模块是哪个模块的哪个函数）。<br>一般来说，函数调用者如果关心具体的错误信息的话，可以使用一个类型switch来获取具体的错误类型和相信信息。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for try :&#x3D; 0; try &lt; 2; try++ &#123;</span><br><span class="line">    file, err &#x3D; os.Create(filename)</span><br><span class="line">    if err &#x3D;&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    if e, ok :&#x3D; err.(*os.PathError); ok &amp;&amp; e.Err &#x3D;&#x3D; syscall.ENOSPC &#123;</span><br><span class="line">        deleteTempFiles()  &#x2F;&#x2F; Recover some space.</span><br><span class="line">        continue</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="Panic"   >
          <a href="#Panic" class="heading-link"><i class="fas fa-link"></i></a>Panic</h2>
      <p>对于预设以内的错误，返回错误的方式应该是返回错误的信息为多一个参数.</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func Get() (string, Error)&#123;</span><br><span class="line">    return &quot;&quot;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k, err :&#x3D; Get()</span><br></pre></td></tr></table></div></figure>
<p>但是对于不可恢复的错误，我们不能让程序继续运行。<br>Panic()的作用是创建一个Runtime Error并且使得程序无法继续运行。<br>Panic可以接受任意长度的参数，并且打印到日志上，</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func CubeRoot(x float64) float64 &#123;</span><br><span class="line">    z :&#x3D; x&#x2F;3   &#x2F;&#x2F; Arbitrary initial value</span><br><span class="line">    for i :&#x3D; 0; i &lt; 1e6; i++ &#123;</span><br><span class="line">        prevz :&#x3D; z</span><br><span class="line">        z -&#x3D; (z*z*z-x) &#x2F; (3*z*z)</span><br><span class="line">        if veryClose(z, prevz) &#123;</span><br><span class="line">            return z</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; A million iterations has not converged; something is wrong.</span><br><span class="line">    panic(fmt.Sprintf(&quot;CubeRoot(%g) did not converge&quot;, x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>官方对于Panic的态度：程序员应该尽可能的去考虑并且解决所有的异常的情况。<br>对于真实的代码库上面不建议使用这个方法。</p>

        <h2 id="Recover"   >
          <a href="#Recover" class="heading-link"><i class="fas fa-link"></i></a>Recover</h2>
      <p>用于恢复发生Panic的Goroutine。但是必须在panic前面的地方添加一个defer 并且把Recover函数放入其中。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func server(workChan &lt;-chan *Work) &#123;</span><br><span class="line">    for work :&#x3D; range workChan &#123;</span><br><span class="line">        go safelyDo(work)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func safelyDo(work *Work) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        if err :&#x3D; recover(); err !&#x3D; nil &#123;</span><br><span class="line">            log.Println(&quot;work failed:&quot;, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    do(work)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>官方库中处理复杂错误的例子，Regexp</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Error is the type of a parse error; it satisfies the error interface.</span><br><span class="line">type Error string</span><br><span class="line">func (e Error) Error() string &#123;</span><br><span class="line">    return string(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; error is a method of *Regexp that reports parsing errors by</span><br><span class="line">&#x2F;&#x2F; panicking with an Error.</span><br><span class="line">func (regexp *Regexp) error(err string) &#123;</span><br><span class="line">    panic(Error(err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Compile returns a parsed representation of the regular expression.</span><br><span class="line">func Compile(str string) (regexp *Regexp, err error) &#123;</span><br><span class="line">    regexp &#x3D; new(Regexp)</span><br><span class="line">    &#x2F;&#x2F; doParse will panic if there is a parse error.</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        if e :&#x3D; recover(); e !&#x3D; nil &#123;</span><br><span class="line">            regexp &#x3D; nil    &#x2F;&#x2F; Clear return value.</span><br><span class="line">            err &#x3D; e.(Error) &#x2F;&#x2F; Will re-panic if not a parse error.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return regexp.doParse(str), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>即使上面把regexp 的类型变成了nil。但是如果在e判断类型的时候如果不是Error的类型。程序仍然会发生错误，并且崩溃推出。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if pos &#x3D;&#x3D; 0 &#123;</span><br><span class="line">    re.error(&quot;&#39;*&#39; illegal at start of expression&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>对于上面的这种re-panic的策略，官方建议是在一个包内进行使用，这样就不会把错误暴露给Client。<br>虽然re-panic最终程序还是崩溃了，但是这样可以使得程序具体的错误可以过滤一层，并且找到更加直接的错误的原因。</p>

        <h1 id="PackageInit"   >
          <a href="#PackageInit" class="heading-link"><i class="fas fa-link"></i></a>PackageInit</h1>
      <p>可以直接看<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34211611" >译文</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>即可。</p>
<p>也可以直接读介绍的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://medium.com/golangspec/init-functions-in-go-eac191b3860a" >原文</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="Defer"   >
          <a href="#Defer" class="heading-link"><i class="fas fa-link"></i></a>Defer</h1>
      <p>Defer语法是在函数返回前进行调度的清除函数调用。它能够很好地处理多分支返回情况下的释放资源的问题。（类似于Python的With语法）</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func Contents(filename string) (string, error) &#123;</span><br><span class="line">    f, err :&#x3D; os.Open(filename)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return &quot;&quot;, err</span><br><span class="line">    &#125;</span><br><span class="line">    defer f.Close()  &#x2F;&#x2F; f.Close will run when we&#39;re finished.</span><br><span class="line"></span><br><span class="line">    var result []byte</span><br><span class="line">    buf :&#x3D; make([]byte, 100)</span><br><span class="line">    for &#123;</span><br><span class="line">        n, err :&#x3D; f.Read(buf[0:])</span><br><span class="line">        result &#x3D; append(result, buf[0:n]...) &#x2F;&#x2F; append is discussed later.</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            return &quot;&quot;, err  &#x2F;&#x2F; f will be closed if we return here.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return string(result), nil &#x2F;&#x2F; f will be closed if we return here.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">官方对于Defer的好处声明：</span><br><span class="line">1. 位置更加接近，更好的可以清晰的看出操作</span><br><span class="line">2. 防止资源忘了关闭导致的泄露问题</span><br></pre></td></tr></table></div></figure>
<p>延迟函数（如果函数是方法，则包括接收方）的参数在延迟执行时而不是在调用执行时进行评估。除了避免担心函数执行时变量会更改值外，这还意味着单个延迟的调用站点可以延迟多个函数的执行。这是一个简单的例子。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	for i :&#x3D; 0; i &lt; 5; i++ &#123;</span><br><span class="line">    		defer fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line">output:</span><br><span class="line">4 3 2 1 0 </span><br></pre></td></tr></table></div></figure>
<p>Defer函数的执行吮吸是LIFO（LastInFirstOut)栈的结构。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func trace(s string) string &#123;</span><br><span class="line">    fmt.Println(&quot;entering:&quot;, s)</span><br><span class="line">    return s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func un(s string) &#123;</span><br><span class="line">    fmt.Println(&quot;leaving:&quot;, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func a() &#123;</span><br><span class="line">    defer un(trace(&quot;a&quot;))</span><br><span class="line">    fmt.Println(&quot;in a&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func b() &#123;</span><br><span class="line">    defer un(trace(&quot;b&quot;))</span><br><span class="line">    fmt.Println(&quot;in b&quot;)</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br><span class="line">-------------------</span><br><span class="line">output</span><br><span class="line">entering: b</span><br><span class="line">in b</span><br><span class="line">entering: a</span><br><span class="line">in a</span><br><span class="line">leaving: a</span><br><span class="line">leaving: b</span><br></pre></td></tr></table></div></figure>
<p>从上面的例子可以看出来，defer函数只能包含一层，如果像上面的代码 defer un(trace()), 那么会先执行trace()，然后再把un()函数压入defer的栈中。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/_wZQID0VatIlAiH6-x3U6A" >更加实际的使用场景相关的例子</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="ShareNote"   >
          <a href="#ShareNote" class="heading-link"><i class="fas fa-link"></i></a>ShareNote</h1>
      <ol>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://golang.org/doc/effective_go.html" >EffectiveGo</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://medium.com/golangspec/init-functions-in-go-eac191b3860a" >GoInitFunc</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34211611" >GoInitFunc译文</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://example.com">Ray Chen</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://example.com/2019/09/16/effective-go/">http://example.com/2019/09/16/effective-go/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://example.com/tags/Go/">Go</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2019/10/05/prometheus-service-discovery/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">Prometheus服务发现源码阅读</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2019/09/10/sql-revise/"><span class="paginator-prev__text">SQL复习</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">
          目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Method"><span class="toc-number">2.</span> <span class="toc-text">
          Method</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Pointers-vs-Values"><span class="toc-number">2.1.</span> <span class="toc-text">
          Pointers vs Values</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Data"><span class="toc-number">3.</span> <span class="toc-text">
          Data</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#New-vs-Make"><span class="toc-number">3.1.</span> <span class="toc-text">
          New vs Make</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#New"><span class="toc-number">3.1.1.</span> <span class="toc-text">
          New</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Make"><span class="toc-number">3.1.2.</span> <span class="toc-text">
          Make</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Diff"><span class="toc-number">3.1.3.</span> <span class="toc-text">
          Diff</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array"><span class="toc-number">3.2.</span> <span class="toc-text">
          Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Slice"><span class="toc-number">3.3.</span> <span class="toc-text">
          Slice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%92%8C%E4%BA%8C%E7%BB%B4%E5%88%87%E7%89%87"><span class="toc-number">3.3.1.</span> <span class="toc-text">
          二维数组和二维切片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-number">3.4.</span> <span class="toc-text">
          Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Append"><span class="toc-number">3.5.</span> <span class="toc-text">
          Append</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#InterFace"><span class="toc-number">4.</span> <span class="toc-text">
          InterFace</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Interface"><span class="toc-number">4.1.</span> <span class="toc-text">
          Interface</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Coversions"><span class="toc-number">4.2.</span> <span class="toc-text">
          Coversions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-assertions"><span class="toc-number">4.3.</span> <span class="toc-text">
          type assertions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generality"><span class="toc-number">4.4.</span> <span class="toc-text">
          Generality</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#interface-amp-method"><span class="toc-number">4.5.</span> <span class="toc-text">
          interface &amp; method</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Error"><span class="toc-number">5.</span> <span class="toc-text">
          Error</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Defination"><span class="toc-number">5.1.</span> <span class="toc-text">
          Defination</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Panic"><span class="toc-number">5.2.</span> <span class="toc-text">
          Panic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Recover"><span class="toc-number">5.3.</span> <span class="toc-text">
          Recover</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PackageInit"><span class="toc-number">6.</span> <span class="toc-text">
          PackageInit</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Defer"><span class="toc-number">7.</span> <span class="toc-text">
          Defer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ShareNote"><span class="toc-number">8.</span> <span class="toc-text">
          ShareNote</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/header.jpeg" alt="avatar"></div><p class="sidebar-ov-author__text">Believe in Goods in People</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">13</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">5</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Ray Chen</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.1"></script><script src="/js/stun-boot.js?v=2.6.1"></script><script src="/js/scroll.js?v=2.6.1"></script><script src="/js/header.js?v=2.6.1"></script><script src="/js/sidebar.js?v=2.6.1"></script></body></html>